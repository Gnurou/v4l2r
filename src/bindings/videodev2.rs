/* automatically generated by rust-bindgen */

pub const _SYS_TIME_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 1024;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const __BITS_PER_LONG: u32 = 64;
pub const V4L2_SEL_TGT_CROP: u32 = 0;
pub const V4L2_SEL_TGT_CROP_DEFAULT: u32 = 1;
pub const V4L2_SEL_TGT_CROP_BOUNDS: u32 = 2;
pub const V4L2_SEL_TGT_NATIVE_SIZE: u32 = 3;
pub const V4L2_SEL_TGT_COMPOSE: u32 = 256;
pub const V4L2_SEL_TGT_COMPOSE_DEFAULT: u32 = 257;
pub const V4L2_SEL_TGT_COMPOSE_BOUNDS: u32 = 258;
pub const V4L2_SEL_TGT_COMPOSE_PADDED: u32 = 259;
pub const V4L2_SEL_FLAG_GE: u32 = 1;
pub const V4L2_SEL_FLAG_LE: u32 = 2;
pub const V4L2_SEL_FLAG_KEEP_CONFIG: u32 = 4;
pub const V4L2_SEL_TGT_CROP_ACTIVE: u32 = 0;
pub const V4L2_SEL_TGT_COMPOSE_ACTIVE: u32 = 256;
pub const V4L2_SUBDEV_SEL_TGT_CROP_ACTUAL: u32 = 0;
pub const V4L2_SUBDEV_SEL_TGT_COMPOSE_ACTUAL: u32 = 256;
pub const V4L2_SUBDEV_SEL_TGT_CROP_BOUNDS: u32 = 2;
pub const V4L2_SUBDEV_SEL_TGT_COMPOSE_BOUNDS: u32 = 258;
pub const V4L2_SUBDEV_SEL_FLAG_SIZE_GE: u32 = 1;
pub const V4L2_SUBDEV_SEL_FLAG_SIZE_LE: u32 = 2;
pub const V4L2_SUBDEV_SEL_FLAG_KEEP_CONFIG: u32 = 4;
pub const V4L2_CTRL_CLASS_USER: u32 = 9961472;
pub const V4L2_CTRL_CLASS_MPEG: u32 = 10027008;
pub const V4L2_CTRL_CLASS_CAMERA: u32 = 10092544;
pub const V4L2_CTRL_CLASS_FM_TX: u32 = 10158080;
pub const V4L2_CTRL_CLASS_FLASH: u32 = 10223616;
pub const V4L2_CTRL_CLASS_JPEG: u32 = 10289152;
pub const V4L2_CTRL_CLASS_IMAGE_SOURCE: u32 = 10354688;
pub const V4L2_CTRL_CLASS_IMAGE_PROC: u32 = 10420224;
pub const V4L2_CTRL_CLASS_DV: u32 = 10485760;
pub const V4L2_CTRL_CLASS_FM_RX: u32 = 10551296;
pub const V4L2_CTRL_CLASS_RF_TUNER: u32 = 10616832;
pub const V4L2_CTRL_CLASS_DETECT: u32 = 10682368;
pub const V4L2_CID_BASE: u32 = 9963776;
pub const V4L2_CID_USER_BASE: u32 = 9963776;
pub const V4L2_CID_USER_CLASS: u32 = 9961473;
pub const V4L2_CID_BRIGHTNESS: u32 = 9963776;
pub const V4L2_CID_CONTRAST: u32 = 9963777;
pub const V4L2_CID_SATURATION: u32 = 9963778;
pub const V4L2_CID_HUE: u32 = 9963779;
pub const V4L2_CID_AUDIO_VOLUME: u32 = 9963781;
pub const V4L2_CID_AUDIO_BALANCE: u32 = 9963782;
pub const V4L2_CID_AUDIO_BASS: u32 = 9963783;
pub const V4L2_CID_AUDIO_TREBLE: u32 = 9963784;
pub const V4L2_CID_AUDIO_MUTE: u32 = 9963785;
pub const V4L2_CID_AUDIO_LOUDNESS: u32 = 9963786;
pub const V4L2_CID_BLACK_LEVEL: u32 = 9963787;
pub const V4L2_CID_AUTO_WHITE_BALANCE: u32 = 9963788;
pub const V4L2_CID_DO_WHITE_BALANCE: u32 = 9963789;
pub const V4L2_CID_RED_BALANCE: u32 = 9963790;
pub const V4L2_CID_BLUE_BALANCE: u32 = 9963791;
pub const V4L2_CID_GAMMA: u32 = 9963792;
pub const V4L2_CID_WHITENESS: u32 = 9963792;
pub const V4L2_CID_EXPOSURE: u32 = 9963793;
pub const V4L2_CID_AUTOGAIN: u32 = 9963794;
pub const V4L2_CID_GAIN: u32 = 9963795;
pub const V4L2_CID_HFLIP: u32 = 9963796;
pub const V4L2_CID_VFLIP: u32 = 9963797;
pub const V4L2_CID_POWER_LINE_FREQUENCY: u32 = 9963800;
pub const V4L2_CID_HUE_AUTO: u32 = 9963801;
pub const V4L2_CID_WHITE_BALANCE_TEMPERATURE: u32 = 9963802;
pub const V4L2_CID_SHARPNESS: u32 = 9963803;
pub const V4L2_CID_BACKLIGHT_COMPENSATION: u32 = 9963804;
pub const V4L2_CID_CHROMA_AGC: u32 = 9963805;
pub const V4L2_CID_COLOR_KILLER: u32 = 9963806;
pub const V4L2_CID_COLORFX: u32 = 9963807;
pub const V4L2_CID_AUTOBRIGHTNESS: u32 = 9963808;
pub const V4L2_CID_BAND_STOP_FILTER: u32 = 9963809;
pub const V4L2_CID_ROTATE: u32 = 9963810;
pub const V4L2_CID_BG_COLOR: u32 = 9963811;
pub const V4L2_CID_CHROMA_GAIN: u32 = 9963812;
pub const V4L2_CID_ILLUMINATORS_1: u32 = 9963813;
pub const V4L2_CID_ILLUMINATORS_2: u32 = 9963814;
pub const V4L2_CID_MIN_BUFFERS_FOR_CAPTURE: u32 = 9963815;
pub const V4L2_CID_MIN_BUFFERS_FOR_OUTPUT: u32 = 9963816;
pub const V4L2_CID_ALPHA_COMPONENT: u32 = 9963817;
pub const V4L2_CID_COLORFX_CBCR: u32 = 9963818;
pub const V4L2_CID_LASTP1: u32 = 9963819;
pub const V4L2_CID_USER_MEYE_BASE: u32 = 9967872;
pub const V4L2_CID_USER_BTTV_BASE: u32 = 9967888;
pub const V4L2_CID_USER_S2255_BASE: u32 = 9967920;
pub const V4L2_CID_USER_SI476X_BASE: u32 = 9967936;
pub const V4L2_CID_USER_TI_VPE_BASE: u32 = 9967952;
pub const V4L2_CID_USER_SAA7134_BASE: u32 = 9967968;
pub const V4L2_CID_USER_ADV7180_BASE: u32 = 9967984;
pub const V4L2_CID_USER_TC358743_BASE: u32 = 9968000;
pub const V4L2_CID_USER_MAX217X_BASE: u32 = 9968016;
pub const V4L2_CID_USER_IMX_BASE: u32 = 9968048;
pub const V4L2_CID_MPEG_BASE: u32 = 10029312;
pub const V4L2_CID_MPEG_CLASS: u32 = 10027009;
pub const V4L2_CID_MPEG_STREAM_TYPE: u32 = 10029312;
pub const V4L2_CID_MPEG_STREAM_PID_PMT: u32 = 10029313;
pub const V4L2_CID_MPEG_STREAM_PID_AUDIO: u32 = 10029314;
pub const V4L2_CID_MPEG_STREAM_PID_VIDEO: u32 = 10029315;
pub const V4L2_CID_MPEG_STREAM_PID_PCR: u32 = 10029316;
pub const V4L2_CID_MPEG_STREAM_PES_ID_AUDIO: u32 = 10029317;
pub const V4L2_CID_MPEG_STREAM_PES_ID_VIDEO: u32 = 10029318;
pub const V4L2_CID_MPEG_STREAM_VBI_FMT: u32 = 10029319;
pub const V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ: u32 = 10029412;
pub const V4L2_CID_MPEG_AUDIO_ENCODING: u32 = 10029413;
pub const V4L2_CID_MPEG_AUDIO_L1_BITRATE: u32 = 10029414;
pub const V4L2_CID_MPEG_AUDIO_L2_BITRATE: u32 = 10029415;
pub const V4L2_CID_MPEG_AUDIO_L3_BITRATE: u32 = 10029416;
pub const V4L2_CID_MPEG_AUDIO_MODE: u32 = 10029417;
pub const V4L2_CID_MPEG_AUDIO_MODE_EXTENSION: u32 = 10029418;
pub const V4L2_CID_MPEG_AUDIO_EMPHASIS: u32 = 10029419;
pub const V4L2_CID_MPEG_AUDIO_CRC: u32 = 10029420;
pub const V4L2_CID_MPEG_AUDIO_MUTE: u32 = 10029421;
pub const V4L2_CID_MPEG_AUDIO_AAC_BITRATE: u32 = 10029422;
pub const V4L2_CID_MPEG_AUDIO_AC3_BITRATE: u32 = 10029423;
pub const V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK: u32 = 10029424;
pub const V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK: u32 = 10029425;
pub const V4L2_CID_MPEG_VIDEO_ENCODING: u32 = 10029512;
pub const V4L2_CID_MPEG_VIDEO_ASPECT: u32 = 10029513;
pub const V4L2_CID_MPEG_VIDEO_B_FRAMES: u32 = 10029514;
pub const V4L2_CID_MPEG_VIDEO_GOP_SIZE: u32 = 10029515;
pub const V4L2_CID_MPEG_VIDEO_GOP_CLOSURE: u32 = 10029516;
pub const V4L2_CID_MPEG_VIDEO_PULLDOWN: u32 = 10029517;
pub const V4L2_CID_MPEG_VIDEO_BITRATE_MODE: u32 = 10029518;
pub const V4L2_CID_MPEG_VIDEO_BITRATE: u32 = 10029519;
pub const V4L2_CID_MPEG_VIDEO_BITRATE_PEAK: u32 = 10029520;
pub const V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION: u32 = 10029521;
pub const V4L2_CID_MPEG_VIDEO_MUTE: u32 = 10029522;
pub const V4L2_CID_MPEG_VIDEO_MUTE_YUV: u32 = 10029523;
pub const V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE: u32 = 10029524;
pub const V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER: u32 = 10029525;
pub const V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB: u32 = 10029526;
pub const V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE: u32 = 10029527;
pub const V4L2_CID_MPEG_VIDEO_HEADER_MODE: u32 = 10029528;
pub const V4L2_CID_MPEG_VIDEO_MAX_REF_PIC: u32 = 10029529;
pub const V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE: u32 = 10029530;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES: u32 = 10029531;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB: u32 = 10029532;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE: u32 = 10029533;
pub const V4L2_CID_MPEG_VIDEO_VBV_SIZE: u32 = 10029534;
pub const V4L2_CID_MPEG_VIDEO_DEC_PTS: u32 = 10029535;
pub const V4L2_CID_MPEG_VIDEO_DEC_FRAME: u32 = 10029536;
pub const V4L2_CID_MPEG_VIDEO_VBV_DELAY: u32 = 10029537;
pub const V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER: u32 = 10029538;
pub const V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE: u32 = 10029539;
pub const V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE: u32 = 10029540;
pub const V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME: u32 = 10029541;
pub const V4L2_CID_MPEG_VIDEO_MPEG2_LEVEL: u32 = 10029582;
pub const V4L2_CID_MPEG_VIDEO_MPEG2_PROFILE: u32 = 10029583;
pub const V4L2_CID_FWHT_I_FRAME_QP: u32 = 10029602;
pub const V4L2_CID_FWHT_P_FRAME_QP: u32 = 10029603;
pub const V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP: u32 = 10029612;
pub const V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP: u32 = 10029613;
pub const V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP: u32 = 10029614;
pub const V4L2_CID_MPEG_VIDEO_H263_MIN_QP: u32 = 10029615;
pub const V4L2_CID_MPEG_VIDEO_H263_MAX_QP: u32 = 10029616;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP: u32 = 10029662;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP: u32 = 10029663;
pub const V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP: u32 = 10029664;
pub const V4L2_CID_MPEG_VIDEO_H264_MIN_QP: u32 = 10029665;
pub const V4L2_CID_MPEG_VIDEO_H264_MAX_QP: u32 = 10029666;
pub const V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM: u32 = 10029667;
pub const V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE: u32 = 10029668;
pub const V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE: u32 = 10029669;
pub const V4L2_CID_MPEG_VIDEO_H264_I_PERIOD: u32 = 10029670;
pub const V4L2_CID_MPEG_VIDEO_H264_LEVEL: u32 = 10029671;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA: u32 = 10029672;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA: u32 = 10029673;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE: u32 = 10029674;
pub const V4L2_CID_MPEG_VIDEO_H264_PROFILE: u32 = 10029675;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT: u32 = 10029676;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH: u32 = 10029677;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE: u32 = 10029678;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC: u32 = 10029679;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING: u32 = 10029680;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0: u32 = 10029681;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE: u32 = 10029682;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO: u32 = 10029683;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE: u32 = 10029684;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP: u32 = 10029685;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION: u32 = 10029686;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE: u32 = 10029687;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH: u32 = 10029688;
pub const V4L2_CID_MPEG_VIDEO_H264_ASO: u32 = 10029689;
pub const V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER: u32 = 10029690;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING: u32 = 10029691;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE: u32 = 10029692;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER: u32 = 10029693;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP: u32 = 10029694;
pub const V4L2_CID_MPEG_VIDEO_H264_CONSTRAINED_INTRA_PREDICTION: u32 = 10029695;
pub const V4L2_CID_MPEG_VIDEO_H264_CHROMA_QP_INDEX_OFFSET: u32 = 10029696;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_MIN_QP: u32 = 10029697;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_MAX_QP: u32 = 10029698;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_MIN_QP: u32 = 10029699;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_MAX_QP: u32 = 10029700;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP: u32 = 10029712;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP: u32 = 10029713;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP: u32 = 10029714;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP: u32 = 10029715;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP: u32 = 10029716;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL: u32 = 10029717;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE: u32 = 10029718;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_QPEL: u32 = 10029719;
pub const V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS: u32 = 10029812;
pub const V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4: u32 = 10029813;
pub const V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES: u32 = 10029814;
pub const V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL: u32 = 10029815;
pub const V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS: u32 = 10029816;
pub const V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD: u32 = 10029817;
pub const V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL: u32 = 10029818;
pub const V4L2_CID_MPEG_VIDEO_VPX_MIN_QP: u32 = 10029819;
pub const V4L2_CID_MPEG_VIDEO_VPX_MAX_QP: u32 = 10029820;
pub const V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP: u32 = 10029821;
pub const V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP: u32 = 10029822;
pub const V4L2_CID_MPEG_VIDEO_VP8_PROFILE: u32 = 10029823;
pub const V4L2_CID_MPEG_VIDEO_VPX_PROFILE: u32 = 10029823;
pub const V4L2_CID_MPEG_VIDEO_VP9_PROFILE: u32 = 10029824;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP: u32 = 10029912;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP: u32 = 10029913;
pub const V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP: u32 = 10029914;
pub const V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP: u32 = 10029915;
pub const V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP: u32 = 10029916;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_QP: u32 = 10029917;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_TYPE: u32 = 10029918;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_LAYER: u32 = 10029919;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_QP: u32 = 10029920;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_QP: u32 = 10029921;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_QP: u32 = 10029922;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_QP: u32 = 10029923;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_QP: u32 = 10029924;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_QP: u32 = 10029925;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_QP: u32 = 10029926;
pub const V4L2_CID_MPEG_VIDEO_HEVC_PROFILE: u32 = 10029927;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LEVEL: u32 = 10029928;
pub const V4L2_CID_MPEG_VIDEO_HEVC_FRAME_RATE_RESOLUTION: u32 = 10029929;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TIER: u32 = 10029930;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_PARTITION_DEPTH: u32 = 10029931;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE: u32 = 10029932;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LF_BETA_OFFSET_DIV2: u32 = 10029933;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LF_TC_OFFSET_DIV2: u32 = 10029934;
pub const V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_TYPE: u32 = 10029935;
pub const V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_PERIOD: u32 = 10029936;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LOSSLESS_CU: u32 = 10029937;
pub const V4L2_CID_MPEG_VIDEO_HEVC_CONST_INTRA_PRED: u32 = 10029938;
pub const V4L2_CID_MPEG_VIDEO_HEVC_WAVEFRONT: u32 = 10029939;
pub const V4L2_CID_MPEG_VIDEO_HEVC_GENERAL_PB: u32 = 10029940;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TEMPORAL_ID: u32 = 10029941;
pub const V4L2_CID_MPEG_VIDEO_HEVC_STRONG_SMOOTHING: u32 = 10029942;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_NUM_MERGE_MV_MINUS1: u32 = 10029943;
pub const V4L2_CID_MPEG_VIDEO_HEVC_INTRA_PU_SPLIT: u32 = 10029944;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TMV_PREDICTION: u32 = 10029945;
pub const V4L2_CID_MPEG_VIDEO_HEVC_WITHOUT_STARTCODE: u32 = 10029946;
pub const V4L2_CID_MPEG_VIDEO_HEVC_SIZE_OF_LENGTH_FIELD: u32 = 10029947;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_BR: u32 = 10029948;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_BR: u32 = 10029949;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_BR: u32 = 10029950;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_BR: u32 = 10029951;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_BR: u32 = 10029952;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_BR: u32 = 10029953;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_BR: u32 = 10029954;
pub const V4L2_CID_MPEG_VIDEO_REF_NUMBER_FOR_PFRAMES: u32 = 10029955;
pub const V4L2_CID_MPEG_VIDEO_PREPEND_SPSPPS_TO_IDR: u32 = 10029956;
pub const V4L2_CID_MPEG_CX2341X_BASE: u32 = 10031104;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE: u32 = 10031104;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER: u32 = 10031105;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE: u32 = 10031106;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE: u32 = 10031107;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE: u32 = 10031108;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER: u32 = 10031109;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE: u32 = 10031110;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM: u32 = 10031111;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP: u32 = 10031112;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM: u32 = 10031113;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP: u32 = 10031114;
pub const V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS: u32 = 10031115;
pub const V4L2_CID_MPEG_MFC51_BASE: u32 = 10031360;
pub const V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY: u32 = 10031360;
pub const V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE: u32 = 10031361;
pub const V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE: u32 = 10031362;
pub const V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE: u32 = 10031363;
pub const V4L2_CID_MPEG_MFC51_VIDEO_PADDING: u32 = 10031364;
pub const V4L2_CID_MPEG_MFC51_VIDEO_PADDING_YUV: u32 = 10031365;
pub const V4L2_CID_MPEG_MFC51_VIDEO_RC_FIXED_TARGET_BIT: u32 = 10031366;
pub const V4L2_CID_MPEG_MFC51_VIDEO_RC_REACTION_COEFF: u32 = 10031367;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_ACTIVITY: u32 = 10031410;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_DARK: u32 = 10031411;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_SMOOTH: u32 = 10031412;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_STATIC: u32 = 10031413;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_NUM_REF_PIC_FOR_P: u32 = 10031414;
pub const V4L2_CID_CAMERA_CLASS_BASE: u32 = 10094848;
pub const V4L2_CID_CAMERA_CLASS: u32 = 10092545;
pub const V4L2_CID_EXPOSURE_AUTO: u32 = 10094849;
pub const V4L2_CID_EXPOSURE_ABSOLUTE: u32 = 10094850;
pub const V4L2_CID_EXPOSURE_AUTO_PRIORITY: u32 = 10094851;
pub const V4L2_CID_PAN_RELATIVE: u32 = 10094852;
pub const V4L2_CID_TILT_RELATIVE: u32 = 10094853;
pub const V4L2_CID_PAN_RESET: u32 = 10094854;
pub const V4L2_CID_TILT_RESET: u32 = 10094855;
pub const V4L2_CID_PAN_ABSOLUTE: u32 = 10094856;
pub const V4L2_CID_TILT_ABSOLUTE: u32 = 10094857;
pub const V4L2_CID_FOCUS_ABSOLUTE: u32 = 10094858;
pub const V4L2_CID_FOCUS_RELATIVE: u32 = 10094859;
pub const V4L2_CID_FOCUS_AUTO: u32 = 10094860;
pub const V4L2_CID_ZOOM_ABSOLUTE: u32 = 10094861;
pub const V4L2_CID_ZOOM_RELATIVE: u32 = 10094862;
pub const V4L2_CID_ZOOM_CONTINUOUS: u32 = 10094863;
pub const V4L2_CID_PRIVACY: u32 = 10094864;
pub const V4L2_CID_IRIS_ABSOLUTE: u32 = 10094865;
pub const V4L2_CID_IRIS_RELATIVE: u32 = 10094866;
pub const V4L2_CID_AUTO_EXPOSURE_BIAS: u32 = 10094867;
pub const V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE: u32 = 10094868;
pub const V4L2_CID_WIDE_DYNAMIC_RANGE: u32 = 10094869;
pub const V4L2_CID_IMAGE_STABILIZATION: u32 = 10094870;
pub const V4L2_CID_ISO_SENSITIVITY: u32 = 10094871;
pub const V4L2_CID_ISO_SENSITIVITY_AUTO: u32 = 10094872;
pub const V4L2_CID_EXPOSURE_METERING: u32 = 10094873;
pub const V4L2_CID_SCENE_MODE: u32 = 10094874;
pub const V4L2_CID_3A_LOCK: u32 = 10094875;
pub const V4L2_LOCK_EXPOSURE: u32 = 1;
pub const V4L2_LOCK_WHITE_BALANCE: u32 = 2;
pub const V4L2_LOCK_FOCUS: u32 = 4;
pub const V4L2_CID_AUTO_FOCUS_START: u32 = 10094876;
pub const V4L2_CID_AUTO_FOCUS_STOP: u32 = 10094877;
pub const V4L2_CID_AUTO_FOCUS_STATUS: u32 = 10094878;
pub const V4L2_AUTO_FOCUS_STATUS_IDLE: u32 = 0;
pub const V4L2_AUTO_FOCUS_STATUS_BUSY: u32 = 1;
pub const V4L2_AUTO_FOCUS_STATUS_REACHED: u32 = 2;
pub const V4L2_AUTO_FOCUS_STATUS_FAILED: u32 = 4;
pub const V4L2_CID_AUTO_FOCUS_RANGE: u32 = 10094879;
pub const V4L2_CID_PAN_SPEED: u32 = 10094880;
pub const V4L2_CID_TILT_SPEED: u32 = 10094881;
pub const V4L2_CID_FM_TX_CLASS_BASE: u32 = 10160384;
pub const V4L2_CID_FM_TX_CLASS: u32 = 10158081;
pub const V4L2_CID_RDS_TX_DEVIATION: u32 = 10160385;
pub const V4L2_CID_RDS_TX_PI: u32 = 10160386;
pub const V4L2_CID_RDS_TX_PTY: u32 = 10160387;
pub const V4L2_CID_RDS_TX_PS_NAME: u32 = 10160389;
pub const V4L2_CID_RDS_TX_RADIO_TEXT: u32 = 10160390;
pub const V4L2_CID_RDS_TX_MONO_STEREO: u32 = 10160391;
pub const V4L2_CID_RDS_TX_ARTIFICIAL_HEAD: u32 = 10160392;
pub const V4L2_CID_RDS_TX_COMPRESSED: u32 = 10160393;
pub const V4L2_CID_RDS_TX_DYNAMIC_PTY: u32 = 10160394;
pub const V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT: u32 = 10160395;
pub const V4L2_CID_RDS_TX_TRAFFIC_PROGRAM: u32 = 10160396;
pub const V4L2_CID_RDS_TX_MUSIC_SPEECH: u32 = 10160397;
pub const V4L2_CID_RDS_TX_ALT_FREQS_ENABLE: u32 = 10160398;
pub const V4L2_CID_RDS_TX_ALT_FREQS: u32 = 10160399;
pub const V4L2_CID_AUDIO_LIMITER_ENABLED: u32 = 10160448;
pub const V4L2_CID_AUDIO_LIMITER_RELEASE_TIME: u32 = 10160449;
pub const V4L2_CID_AUDIO_LIMITER_DEVIATION: u32 = 10160450;
pub const V4L2_CID_AUDIO_COMPRESSION_ENABLED: u32 = 10160464;
pub const V4L2_CID_AUDIO_COMPRESSION_GAIN: u32 = 10160465;
pub const V4L2_CID_AUDIO_COMPRESSION_THRESHOLD: u32 = 10160466;
pub const V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME: u32 = 10160467;
pub const V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME: u32 = 10160468;
pub const V4L2_CID_PILOT_TONE_ENABLED: u32 = 10160480;
pub const V4L2_CID_PILOT_TONE_DEVIATION: u32 = 10160481;
pub const V4L2_CID_PILOT_TONE_FREQUENCY: u32 = 10160482;
pub const V4L2_CID_TUNE_PREEMPHASIS: u32 = 10160496;
pub const V4L2_CID_TUNE_POWER_LEVEL: u32 = 10160497;
pub const V4L2_CID_TUNE_ANTENNA_CAPACITOR: u32 = 10160498;
pub const V4L2_CID_FLASH_CLASS_BASE: u32 = 10225920;
pub const V4L2_CID_FLASH_CLASS: u32 = 10223617;
pub const V4L2_CID_FLASH_LED_MODE: u32 = 10225921;
pub const V4L2_CID_FLASH_STROBE_SOURCE: u32 = 10225922;
pub const V4L2_CID_FLASH_STROBE: u32 = 10225923;
pub const V4L2_CID_FLASH_STROBE_STOP: u32 = 10225924;
pub const V4L2_CID_FLASH_STROBE_STATUS: u32 = 10225925;
pub const V4L2_CID_FLASH_TIMEOUT: u32 = 10225926;
pub const V4L2_CID_FLASH_INTENSITY: u32 = 10225927;
pub const V4L2_CID_FLASH_TORCH_INTENSITY: u32 = 10225928;
pub const V4L2_CID_FLASH_INDICATOR_INTENSITY: u32 = 10225929;
pub const V4L2_CID_FLASH_FAULT: u32 = 10225930;
pub const V4L2_FLASH_FAULT_OVER_VOLTAGE: u32 = 1;
pub const V4L2_FLASH_FAULT_TIMEOUT: u32 = 2;
pub const V4L2_FLASH_FAULT_OVER_TEMPERATURE: u32 = 4;
pub const V4L2_FLASH_FAULT_SHORT_CIRCUIT: u32 = 8;
pub const V4L2_FLASH_FAULT_OVER_CURRENT: u32 = 16;
pub const V4L2_FLASH_FAULT_INDICATOR: u32 = 32;
pub const V4L2_FLASH_FAULT_UNDER_VOLTAGE: u32 = 64;
pub const V4L2_FLASH_FAULT_INPUT_VOLTAGE: u32 = 128;
pub const V4L2_FLASH_FAULT_LED_OVER_TEMPERATURE: u32 = 256;
pub const V4L2_CID_FLASH_CHARGE: u32 = 10225931;
pub const V4L2_CID_FLASH_READY: u32 = 10225932;
pub const V4L2_CID_JPEG_CLASS_BASE: u32 = 10291456;
pub const V4L2_CID_JPEG_CLASS: u32 = 10289153;
pub const V4L2_CID_JPEG_CHROMA_SUBSAMPLING: u32 = 10291457;
pub const V4L2_CID_JPEG_RESTART_INTERVAL: u32 = 10291458;
pub const V4L2_CID_JPEG_COMPRESSION_QUALITY: u32 = 10291459;
pub const V4L2_CID_JPEG_ACTIVE_MARKER: u32 = 10291460;
pub const V4L2_JPEG_ACTIVE_MARKER_APP0: u32 = 1;
pub const V4L2_JPEG_ACTIVE_MARKER_APP1: u32 = 2;
pub const V4L2_JPEG_ACTIVE_MARKER_COM: u32 = 65536;
pub const V4L2_JPEG_ACTIVE_MARKER_DQT: u32 = 131072;
pub const V4L2_JPEG_ACTIVE_MARKER_DHT: u32 = 262144;
pub const V4L2_CID_IMAGE_SOURCE_CLASS_BASE: u32 = 10356992;
pub const V4L2_CID_IMAGE_SOURCE_CLASS: u32 = 10354689;
pub const V4L2_CID_VBLANK: u32 = 10356993;
pub const V4L2_CID_HBLANK: u32 = 10356994;
pub const V4L2_CID_ANALOGUE_GAIN: u32 = 10356995;
pub const V4L2_CID_TEST_PATTERN_RED: u32 = 10356996;
pub const V4L2_CID_TEST_PATTERN_GREENR: u32 = 10356997;
pub const V4L2_CID_TEST_PATTERN_BLUE: u32 = 10356998;
pub const V4L2_CID_TEST_PATTERN_GREENB: u32 = 10356999;
pub const V4L2_CID_IMAGE_PROC_CLASS_BASE: u32 = 10422528;
pub const V4L2_CID_IMAGE_PROC_CLASS: u32 = 10420225;
pub const V4L2_CID_LINK_FREQ: u32 = 10422529;
pub const V4L2_CID_PIXEL_RATE: u32 = 10422530;
pub const V4L2_CID_TEST_PATTERN: u32 = 10422531;
pub const V4L2_CID_DEINTERLACING_MODE: u32 = 10422532;
pub const V4L2_CID_DIGITAL_GAIN: u32 = 10422533;
pub const V4L2_CID_DV_CLASS_BASE: u32 = 10488064;
pub const V4L2_CID_DV_CLASS: u32 = 10485761;
pub const V4L2_CID_DV_TX_HOTPLUG: u32 = 10488065;
pub const V4L2_CID_DV_TX_RXSENSE: u32 = 10488066;
pub const V4L2_CID_DV_TX_EDID_PRESENT: u32 = 10488067;
pub const V4L2_CID_DV_TX_MODE: u32 = 10488068;
pub const V4L2_CID_DV_TX_RGB_RANGE: u32 = 10488069;
pub const V4L2_CID_DV_TX_IT_CONTENT_TYPE: u32 = 10488070;
pub const V4L2_CID_DV_RX_POWER_PRESENT: u32 = 10488164;
pub const V4L2_CID_DV_RX_RGB_RANGE: u32 = 10488165;
pub const V4L2_CID_DV_RX_IT_CONTENT_TYPE: u32 = 10488166;
pub const V4L2_CID_FM_RX_CLASS_BASE: u32 = 10553600;
pub const V4L2_CID_FM_RX_CLASS: u32 = 10551297;
pub const V4L2_CID_TUNE_DEEMPHASIS: u32 = 10553601;
pub const V4L2_CID_RDS_RECEPTION: u32 = 10553602;
pub const V4L2_CID_RDS_RX_PTY: u32 = 10553603;
pub const V4L2_CID_RDS_RX_PS_NAME: u32 = 10553604;
pub const V4L2_CID_RDS_RX_RADIO_TEXT: u32 = 10553605;
pub const V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT: u32 = 10553606;
pub const V4L2_CID_RDS_RX_TRAFFIC_PROGRAM: u32 = 10553607;
pub const V4L2_CID_RDS_RX_MUSIC_SPEECH: u32 = 10553608;
pub const V4L2_CID_RF_TUNER_CLASS_BASE: u32 = 10619136;
pub const V4L2_CID_RF_TUNER_CLASS: u32 = 10616833;
pub const V4L2_CID_RF_TUNER_BANDWIDTH_AUTO: u32 = 10619147;
pub const V4L2_CID_RF_TUNER_BANDWIDTH: u32 = 10619148;
pub const V4L2_CID_RF_TUNER_RF_GAIN: u32 = 10619168;
pub const V4L2_CID_RF_TUNER_LNA_GAIN_AUTO: u32 = 10619177;
pub const V4L2_CID_RF_TUNER_LNA_GAIN: u32 = 10619178;
pub const V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO: u32 = 10619187;
pub const V4L2_CID_RF_TUNER_MIXER_GAIN: u32 = 10619188;
pub const V4L2_CID_RF_TUNER_IF_GAIN_AUTO: u32 = 10619197;
pub const V4L2_CID_RF_TUNER_IF_GAIN: u32 = 10619198;
pub const V4L2_CID_RF_TUNER_PLL_LOCK: u32 = 10619227;
pub const V4L2_CID_DETECT_CLASS_BASE: u32 = 10684672;
pub const V4L2_CID_DETECT_CLASS: u32 = 10682369;
pub const V4L2_CID_DETECT_MD_MODE: u32 = 10684673;
pub const V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD: u32 = 10684674;
pub const V4L2_CID_DETECT_MD_THRESHOLD_GRID: u32 = 10684675;
pub const V4L2_CID_DETECT_MD_REGION_GRID: u32 = 10684676;
pub const VIDEO_MAX_FRAME: u32 = 32;
pub const VIDEO_MAX_PLANES: u32 = 8;
pub const V4L2_CAP_VIDEO_CAPTURE: u32 = 1;
pub const V4L2_CAP_VIDEO_OUTPUT: u32 = 2;
pub const V4L2_CAP_VIDEO_OVERLAY: u32 = 4;
pub const V4L2_CAP_VBI_CAPTURE: u32 = 16;
pub const V4L2_CAP_VBI_OUTPUT: u32 = 32;
pub const V4L2_CAP_SLICED_VBI_CAPTURE: u32 = 64;
pub const V4L2_CAP_SLICED_VBI_OUTPUT: u32 = 128;
pub const V4L2_CAP_RDS_CAPTURE: u32 = 256;
pub const V4L2_CAP_VIDEO_OUTPUT_OVERLAY: u32 = 512;
pub const V4L2_CAP_HW_FREQ_SEEK: u32 = 1024;
pub const V4L2_CAP_RDS_OUTPUT: u32 = 2048;
pub const V4L2_CAP_VIDEO_CAPTURE_MPLANE: u32 = 4096;
pub const V4L2_CAP_VIDEO_OUTPUT_MPLANE: u32 = 8192;
pub const V4L2_CAP_VIDEO_M2M_MPLANE: u32 = 16384;
pub const V4L2_CAP_VIDEO_M2M: u32 = 32768;
pub const V4L2_CAP_TUNER: u32 = 65536;
pub const V4L2_CAP_AUDIO: u32 = 131072;
pub const V4L2_CAP_RADIO: u32 = 262144;
pub const V4L2_CAP_MODULATOR: u32 = 524288;
pub const V4L2_CAP_SDR_CAPTURE: u32 = 1048576;
pub const V4L2_CAP_EXT_PIX_FORMAT: u32 = 2097152;
pub const V4L2_CAP_SDR_OUTPUT: u32 = 4194304;
pub const V4L2_CAP_META_CAPTURE: u32 = 8388608;
pub const V4L2_CAP_READWRITE: u32 = 16777216;
pub const V4L2_CAP_ASYNCIO: u32 = 33554432;
pub const V4L2_CAP_STREAMING: u32 = 67108864;
pub const V4L2_CAP_META_OUTPUT: u32 = 134217728;
pub const V4L2_CAP_TOUCH: u32 = 268435456;
pub const V4L2_CAP_DEVICE_CAPS: u32 = 2147483648;
pub const V4L2_PIX_FMT_PRIV_MAGIC: u32 = 4276996862;
pub const V4L2_PIX_FMT_FLAG_PREMUL_ALPHA: u32 = 1;
pub const V4L2_FMT_FLAG_COMPRESSED: u32 = 1;
pub const V4L2_FMT_FLAG_EMULATED: u32 = 2;
pub const V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM: u32 = 4;
pub const V4L2_FMT_FLAG_DYN_RESOLUTION: u32 = 8;
pub const V4L2_TC_TYPE_24FPS: u32 = 1;
pub const V4L2_TC_TYPE_25FPS: u32 = 2;
pub const V4L2_TC_TYPE_30FPS: u32 = 3;
pub const V4L2_TC_TYPE_50FPS: u32 = 4;
pub const V4L2_TC_TYPE_60FPS: u32 = 5;
pub const V4L2_TC_FLAG_DROPFRAME: u32 = 1;
pub const V4L2_TC_FLAG_COLORFRAME: u32 = 2;
pub const V4L2_TC_USERBITS_field: u32 = 12;
pub const V4L2_TC_USERBITS_USERDEFINED: u32 = 0;
pub const V4L2_TC_USERBITS_8BITCHARS: u32 = 8;
pub const V4L2_JPEG_MARKER_DHT: u32 = 8;
pub const V4L2_JPEG_MARKER_DQT: u32 = 16;
pub const V4L2_JPEG_MARKER_DRI: u32 = 32;
pub const V4L2_JPEG_MARKER_COM: u32 = 64;
pub const V4L2_JPEG_MARKER_APP: u32 = 128;
pub const V4L2_BUF_CAP_SUPPORTS_MMAP: u32 = 1;
pub const V4L2_BUF_CAP_SUPPORTS_USERPTR: u32 = 2;
pub const V4L2_BUF_CAP_SUPPORTS_DMABUF: u32 = 4;
pub const V4L2_BUF_CAP_SUPPORTS_REQUESTS: u32 = 8;
pub const V4L2_BUF_CAP_SUPPORTS_ORPHANED_BUFS: u32 = 16;
pub const V4L2_BUF_FLAG_MAPPED: u32 = 1;
pub const V4L2_BUF_FLAG_QUEUED: u32 = 2;
pub const V4L2_BUF_FLAG_DONE: u32 = 4;
pub const V4L2_BUF_FLAG_KEYFRAME: u32 = 8;
pub const V4L2_BUF_FLAG_PFRAME: u32 = 16;
pub const V4L2_BUF_FLAG_BFRAME: u32 = 32;
pub const V4L2_BUF_FLAG_ERROR: u32 = 64;
pub const V4L2_BUF_FLAG_IN_REQUEST: u32 = 128;
pub const V4L2_BUF_FLAG_TIMECODE: u32 = 256;
pub const V4L2_BUF_FLAG_PREPARED: u32 = 1024;
pub const V4L2_BUF_FLAG_NO_CACHE_INVALIDATE: u32 = 2048;
pub const V4L2_BUF_FLAG_NO_CACHE_CLEAN: u32 = 4096;
pub const V4L2_BUF_FLAG_TIMESTAMP_MASK: u32 = 57344;
pub const V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN: u32 = 0;
pub const V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC: u32 = 8192;
pub const V4L2_BUF_FLAG_TIMESTAMP_COPY: u32 = 16384;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_MASK: u32 = 458752;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_EOF: u32 = 0;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_SOE: u32 = 65536;
pub const V4L2_BUF_FLAG_LAST: u32 = 1048576;
pub const V4L2_BUF_FLAG_REQUEST_FD: u32 = 8388608;
pub const V4L2_FBUF_CAP_EXTERNOVERLAY: u32 = 1;
pub const V4L2_FBUF_CAP_CHROMAKEY: u32 = 2;
pub const V4L2_FBUF_CAP_LIST_CLIPPING: u32 = 4;
pub const V4L2_FBUF_CAP_BITMAP_CLIPPING: u32 = 8;
pub const V4L2_FBUF_CAP_LOCAL_ALPHA: u32 = 16;
pub const V4L2_FBUF_CAP_GLOBAL_ALPHA: u32 = 32;
pub const V4L2_FBUF_CAP_LOCAL_INV_ALPHA: u32 = 64;
pub const V4L2_FBUF_CAP_SRC_CHROMAKEY: u32 = 128;
pub const V4L2_FBUF_FLAG_PRIMARY: u32 = 1;
pub const V4L2_FBUF_FLAG_OVERLAY: u32 = 2;
pub const V4L2_FBUF_FLAG_CHROMAKEY: u32 = 4;
pub const V4L2_FBUF_FLAG_LOCAL_ALPHA: u32 = 8;
pub const V4L2_FBUF_FLAG_GLOBAL_ALPHA: u32 = 16;
pub const V4L2_FBUF_FLAG_LOCAL_INV_ALPHA: u32 = 32;
pub const V4L2_FBUF_FLAG_SRC_CHROMAKEY: u32 = 64;
pub const V4L2_MODE_HIGHQUALITY: u32 = 1;
pub const V4L2_CAP_TIMEPERFRAME: u32 = 4096;
pub const V4L2_STD_UNKNOWN: u32 = 0;
pub const V4L2_DV_PROGRESSIVE: u32 = 0;
pub const V4L2_DV_INTERLACED: u32 = 1;
pub const V4L2_DV_VSYNC_POS_POL: u32 = 1;
pub const V4L2_DV_HSYNC_POS_POL: u32 = 2;
pub const V4L2_DV_BT_STD_CEA861: u32 = 1;
pub const V4L2_DV_BT_STD_DMT: u32 = 2;
pub const V4L2_DV_BT_STD_CVT: u32 = 4;
pub const V4L2_DV_BT_STD_GTF: u32 = 8;
pub const V4L2_DV_BT_STD_SDI: u32 = 16;
pub const V4L2_DV_FL_REDUCED_BLANKING: u32 = 1;
pub const V4L2_DV_FL_CAN_REDUCE_FPS: u32 = 2;
pub const V4L2_DV_FL_REDUCED_FPS: u32 = 4;
pub const V4L2_DV_FL_HALF_LINE: u32 = 8;
pub const V4L2_DV_FL_IS_CE_VIDEO: u32 = 16;
pub const V4L2_DV_FL_FIRST_FIELD_EXTRA_LINE: u32 = 32;
pub const V4L2_DV_FL_HAS_PICTURE_ASPECT: u32 = 64;
pub const V4L2_DV_FL_HAS_CEA861_VIC: u32 = 128;
pub const V4L2_DV_FL_HAS_HDMI_VIC: u32 = 256;
pub const V4L2_DV_FL_CAN_DETECT_REDUCED_FPS: u32 = 512;
pub const V4L2_DV_BT_656_1120: u32 = 0;
pub const V4L2_DV_BT_CAP_INTERLACED: u32 = 1;
pub const V4L2_DV_BT_CAP_PROGRESSIVE: u32 = 2;
pub const V4L2_DV_BT_CAP_REDUCED_BLANKING: u32 = 4;
pub const V4L2_DV_BT_CAP_CUSTOM: u32 = 8;
pub const V4L2_INPUT_TYPE_TUNER: u32 = 1;
pub const V4L2_INPUT_TYPE_CAMERA: u32 = 2;
pub const V4L2_INPUT_TYPE_TOUCH: u32 = 3;
pub const V4L2_IN_ST_NO_POWER: u32 = 1;
pub const V4L2_IN_ST_NO_SIGNAL: u32 = 2;
pub const V4L2_IN_ST_NO_COLOR: u32 = 4;
pub const V4L2_IN_ST_HFLIP: u32 = 16;
pub const V4L2_IN_ST_VFLIP: u32 = 32;
pub const V4L2_IN_ST_NO_H_LOCK: u32 = 256;
pub const V4L2_IN_ST_COLOR_KILL: u32 = 512;
pub const V4L2_IN_ST_NO_V_LOCK: u32 = 1024;
pub const V4L2_IN_ST_NO_STD_LOCK: u32 = 2048;
pub const V4L2_IN_ST_NO_SYNC: u32 = 65536;
pub const V4L2_IN_ST_NO_EQU: u32 = 131072;
pub const V4L2_IN_ST_NO_CARRIER: u32 = 262144;
pub const V4L2_IN_ST_MACROVISION: u32 = 16777216;
pub const V4L2_IN_ST_NO_ACCESS: u32 = 33554432;
pub const V4L2_IN_ST_VTR: u32 = 67108864;
pub const V4L2_IN_CAP_DV_TIMINGS: u32 = 2;
pub const V4L2_IN_CAP_CUSTOM_TIMINGS: u32 = 2;
pub const V4L2_IN_CAP_STD: u32 = 4;
pub const V4L2_IN_CAP_NATIVE_SIZE: u32 = 8;
pub const V4L2_OUTPUT_TYPE_MODULATOR: u32 = 1;
pub const V4L2_OUTPUT_TYPE_ANALOG: u32 = 2;
pub const V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY: u32 = 3;
pub const V4L2_OUT_CAP_DV_TIMINGS: u32 = 2;
pub const V4L2_OUT_CAP_CUSTOM_TIMINGS: u32 = 2;
pub const V4L2_OUT_CAP_STD: u32 = 4;
pub const V4L2_OUT_CAP_NATIVE_SIZE: u32 = 8;
pub const V4L2_CTRL_ID_MASK: u32 = 268435455;
pub const V4L2_CTRL_MAX_DIMS: u32 = 4;
pub const V4L2_CTRL_WHICH_CUR_VAL: u32 = 0;
pub const V4L2_CTRL_WHICH_DEF_VAL: u32 = 251658240;
pub const V4L2_CTRL_WHICH_REQUEST_VAL: u32 = 251723776;
pub const V4L2_CTRL_FLAG_DISABLED: u32 = 1;
pub const V4L2_CTRL_FLAG_GRABBED: u32 = 2;
pub const V4L2_CTRL_FLAG_READ_ONLY: u32 = 4;
pub const V4L2_CTRL_FLAG_UPDATE: u32 = 8;
pub const V4L2_CTRL_FLAG_INACTIVE: u32 = 16;
pub const V4L2_CTRL_FLAG_SLIDER: u32 = 32;
pub const V4L2_CTRL_FLAG_WRITE_ONLY: u32 = 64;
pub const V4L2_CTRL_FLAG_VOLATILE: u32 = 128;
pub const V4L2_CTRL_FLAG_HAS_PAYLOAD: u32 = 256;
pub const V4L2_CTRL_FLAG_EXECUTE_ON_WRITE: u32 = 512;
pub const V4L2_CTRL_FLAG_MODIFY_LAYOUT: u32 = 1024;
pub const V4L2_CTRL_FLAG_NEXT_CTRL: u32 = 2147483648;
pub const V4L2_CTRL_FLAG_NEXT_COMPOUND: u32 = 1073741824;
pub const V4L2_CID_MAX_CTRLS: u32 = 1024;
pub const V4L2_CID_PRIVATE_BASE: u32 = 134217728;
pub const V4L2_TUNER_CAP_LOW: u32 = 1;
pub const V4L2_TUNER_CAP_NORM: u32 = 2;
pub const V4L2_TUNER_CAP_HWSEEK_BOUNDED: u32 = 4;
pub const V4L2_TUNER_CAP_HWSEEK_WRAP: u32 = 8;
pub const V4L2_TUNER_CAP_STEREO: u32 = 16;
pub const V4L2_TUNER_CAP_LANG2: u32 = 32;
pub const V4L2_TUNER_CAP_SAP: u32 = 32;
pub const V4L2_TUNER_CAP_LANG1: u32 = 64;
pub const V4L2_TUNER_CAP_RDS: u32 = 128;
pub const V4L2_TUNER_CAP_RDS_BLOCK_IO: u32 = 256;
pub const V4L2_TUNER_CAP_RDS_CONTROLS: u32 = 512;
pub const V4L2_TUNER_CAP_FREQ_BANDS: u32 = 1024;
pub const V4L2_TUNER_CAP_HWSEEK_PROG_LIM: u32 = 2048;
pub const V4L2_TUNER_CAP_1HZ: u32 = 4096;
pub const V4L2_TUNER_SUB_MONO: u32 = 1;
pub const V4L2_TUNER_SUB_STEREO: u32 = 2;
pub const V4L2_TUNER_SUB_LANG2: u32 = 4;
pub const V4L2_TUNER_SUB_SAP: u32 = 4;
pub const V4L2_TUNER_SUB_LANG1: u32 = 8;
pub const V4L2_TUNER_SUB_RDS: u32 = 16;
pub const V4L2_TUNER_MODE_MONO: u32 = 0;
pub const V4L2_TUNER_MODE_STEREO: u32 = 1;
pub const V4L2_TUNER_MODE_LANG2: u32 = 2;
pub const V4L2_TUNER_MODE_SAP: u32 = 2;
pub const V4L2_TUNER_MODE_LANG1: u32 = 3;
pub const V4L2_TUNER_MODE_LANG1_LANG2: u32 = 4;
pub const V4L2_BAND_MODULATION_VSB: u32 = 2;
pub const V4L2_BAND_MODULATION_FM: u32 = 4;
pub const V4L2_BAND_MODULATION_AM: u32 = 8;
pub const V4L2_RDS_BLOCK_MSK: u32 = 7;
pub const V4L2_RDS_BLOCK_A: u32 = 0;
pub const V4L2_RDS_BLOCK_B: u32 = 1;
pub const V4L2_RDS_BLOCK_C: u32 = 2;
pub const V4L2_RDS_BLOCK_D: u32 = 3;
pub const V4L2_RDS_BLOCK_C_ALT: u32 = 4;
pub const V4L2_RDS_BLOCK_INVALID: u32 = 7;
pub const V4L2_RDS_BLOCK_CORRECTED: u32 = 64;
pub const V4L2_RDS_BLOCK_ERROR: u32 = 128;
pub const V4L2_AUDCAP_STEREO: u32 = 1;
pub const V4L2_AUDCAP_AVL: u32 = 2;
pub const V4L2_AUDMODE_AVL: u32 = 1;
pub const V4L2_ENC_IDX_FRAME_I: u32 = 0;
pub const V4L2_ENC_IDX_FRAME_P: u32 = 1;
pub const V4L2_ENC_IDX_FRAME_B: u32 = 2;
pub const V4L2_ENC_IDX_FRAME_MASK: u32 = 15;
pub const V4L2_ENC_IDX_ENTRIES: u32 = 64;
pub const V4L2_ENC_CMD_START: u32 = 0;
pub const V4L2_ENC_CMD_STOP: u32 = 1;
pub const V4L2_ENC_CMD_PAUSE: u32 = 2;
pub const V4L2_ENC_CMD_RESUME: u32 = 3;
pub const V4L2_ENC_CMD_STOP_AT_GOP_END: u32 = 1;
pub const V4L2_DEC_CMD_START: u32 = 0;
pub const V4L2_DEC_CMD_STOP: u32 = 1;
pub const V4L2_DEC_CMD_PAUSE: u32 = 2;
pub const V4L2_DEC_CMD_RESUME: u32 = 3;
pub const V4L2_DEC_CMD_START_MUTE_AUDIO: u32 = 1;
pub const V4L2_DEC_CMD_PAUSE_TO_BLACK: u32 = 1;
pub const V4L2_DEC_CMD_STOP_TO_BLACK: u32 = 1;
pub const V4L2_DEC_CMD_STOP_IMMEDIATELY: u32 = 2;
pub const V4L2_DEC_START_FMT_NONE: u32 = 0;
pub const V4L2_DEC_START_FMT_GOP: u32 = 1;
pub const V4L2_VBI_UNSYNC: u32 = 1;
pub const V4L2_VBI_INTERLACED: u32 = 2;
pub const V4L2_VBI_ITU_525_F1_START: u32 = 1;
pub const V4L2_VBI_ITU_525_F2_START: u32 = 264;
pub const V4L2_VBI_ITU_625_F1_START: u32 = 1;
pub const V4L2_VBI_ITU_625_F2_START: u32 = 314;
pub const V4L2_SLICED_TELETEXT_B: u32 = 1;
pub const V4L2_SLICED_VPS: u32 = 1024;
pub const V4L2_SLICED_CAPTION_525: u32 = 4096;
pub const V4L2_SLICED_WSS_625: u32 = 16384;
pub const V4L2_SLICED_VBI_525: u32 = 4096;
pub const V4L2_SLICED_VBI_625: u32 = 17409;
pub const V4L2_MPEG_VBI_IVTV_TELETEXT_B: u32 = 1;
pub const V4L2_MPEG_VBI_IVTV_CAPTION_525: u32 = 4;
pub const V4L2_MPEG_VBI_IVTV_WSS_625: u32 = 5;
pub const V4L2_MPEG_VBI_IVTV_VPS: u32 = 7;
pub const V4L2_MPEG_VBI_IVTV_MAGIC0: &'static [u8; 5usize] = b"itv0\0";
pub const V4L2_MPEG_VBI_IVTV_MAGIC1: &'static [u8; 5usize] = b"ITV0\0";
pub const V4L2_EVENT_ALL: u32 = 0;
pub const V4L2_EVENT_VSYNC: u32 = 1;
pub const V4L2_EVENT_EOS: u32 = 2;
pub const V4L2_EVENT_CTRL: u32 = 3;
pub const V4L2_EVENT_FRAME_SYNC: u32 = 4;
pub const V4L2_EVENT_SOURCE_CHANGE: u32 = 5;
pub const V4L2_EVENT_MOTION_DET: u32 = 6;
pub const V4L2_EVENT_PRIVATE_START: u32 = 134217728;
pub const V4L2_EVENT_CTRL_CH_VALUE: u32 = 1;
pub const V4L2_EVENT_CTRL_CH_FLAGS: u32 = 2;
pub const V4L2_EVENT_CTRL_CH_RANGE: u32 = 4;
pub const V4L2_EVENT_SRC_CH_RESOLUTION: u32 = 1;
pub const V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ: u32 = 1;
pub const V4L2_EVENT_SUB_FL_SEND_INITIAL: u32 = 1;
pub const V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK: u32 = 2;
pub const V4L2_CHIP_MATCH_BRIDGE: u32 = 0;
pub const V4L2_CHIP_MATCH_SUBDEV: u32 = 4;
pub const V4L2_CHIP_MATCH_HOST: u32 = 0;
pub const V4L2_CHIP_MATCH_I2C_DRIVER: u32 = 1;
pub const V4L2_CHIP_MATCH_I2C_ADDR: u32 = 2;
pub const V4L2_CHIP_MATCH_AC97: u32 = 3;
pub const V4L2_CHIP_FL_READABLE: u32 = 1;
pub const V4L2_CHIP_FL_WRITABLE: u32 = 2;
pub const BASE_VIDIOC_PRIVATE: u32 = 192;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_edid {
    pub pad: __u32,
    pub start_block: __u32,
    pub blocks: __u32,
    pub reserved: [__u32; 5usize],
    pub edid: *mut __u8,
}
#[test]
fn bindgen_test_layout_v4l2_edid() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_edid>(),
        40usize,
        concat!("Size of: ", stringify!(v4l2_edid))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_edid>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_edid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_edid>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_edid),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_edid>())).start_block as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_edid),
            "::",
            stringify!(start_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_edid>())).blocks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_edid),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_edid>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_edid),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_edid>())).edid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_edid),
            "::",
            stringify!(edid)
        )
    );
}
pub const v4l2_power_line_frequency_V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:
    v4l2_power_line_frequency = 0;
pub const v4l2_power_line_frequency_V4L2_CID_POWER_LINE_FREQUENCY_50HZ: v4l2_power_line_frequency =
    1;
pub const v4l2_power_line_frequency_V4L2_CID_POWER_LINE_FREQUENCY_60HZ: v4l2_power_line_frequency =
    2;
pub const v4l2_power_line_frequency_V4L2_CID_POWER_LINE_FREQUENCY_AUTO: v4l2_power_line_frequency =
    3;
pub type v4l2_power_line_frequency = u32;
pub const v4l2_colorfx_V4L2_COLORFX_NONE: v4l2_colorfx = 0;
pub const v4l2_colorfx_V4L2_COLORFX_BW: v4l2_colorfx = 1;
pub const v4l2_colorfx_V4L2_COLORFX_SEPIA: v4l2_colorfx = 2;
pub const v4l2_colorfx_V4L2_COLORFX_NEGATIVE: v4l2_colorfx = 3;
pub const v4l2_colorfx_V4L2_COLORFX_EMBOSS: v4l2_colorfx = 4;
pub const v4l2_colorfx_V4L2_COLORFX_SKETCH: v4l2_colorfx = 5;
pub const v4l2_colorfx_V4L2_COLORFX_SKY_BLUE: v4l2_colorfx = 6;
pub const v4l2_colorfx_V4L2_COLORFX_GRASS_GREEN: v4l2_colorfx = 7;
pub const v4l2_colorfx_V4L2_COLORFX_SKIN_WHITEN: v4l2_colorfx = 8;
pub const v4l2_colorfx_V4L2_COLORFX_VIVID: v4l2_colorfx = 9;
pub const v4l2_colorfx_V4L2_COLORFX_AQUA: v4l2_colorfx = 10;
pub const v4l2_colorfx_V4L2_COLORFX_ART_FREEZE: v4l2_colorfx = 11;
pub const v4l2_colorfx_V4L2_COLORFX_SILHOUETTE: v4l2_colorfx = 12;
pub const v4l2_colorfx_V4L2_COLORFX_SOLARIZATION: v4l2_colorfx = 13;
pub const v4l2_colorfx_V4L2_COLORFX_ANTIQUE: v4l2_colorfx = 14;
pub const v4l2_colorfx_V4L2_COLORFX_SET_CBCR: v4l2_colorfx = 15;
pub type v4l2_colorfx = u32;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG2_PS: v4l2_mpeg_stream_type = 0;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG2_TS: v4l2_mpeg_stream_type = 1;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG1_SS: v4l2_mpeg_stream_type = 2;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG2_DVD: v4l2_mpeg_stream_type = 3;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG1_VCD: v4l2_mpeg_stream_type = 4;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD: v4l2_mpeg_stream_type = 5;
pub type v4l2_mpeg_stream_type = u32;
pub const v4l2_mpeg_stream_vbi_fmt_V4L2_MPEG_STREAM_VBI_FMT_NONE: v4l2_mpeg_stream_vbi_fmt = 0;
pub const v4l2_mpeg_stream_vbi_fmt_V4L2_MPEG_STREAM_VBI_FMT_IVTV: v4l2_mpeg_stream_vbi_fmt = 1;
pub type v4l2_mpeg_stream_vbi_fmt = u32;
pub const v4l2_mpeg_audio_sampling_freq_V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100:
    v4l2_mpeg_audio_sampling_freq = 0;
pub const v4l2_mpeg_audio_sampling_freq_V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000:
    v4l2_mpeg_audio_sampling_freq = 1;
pub const v4l2_mpeg_audio_sampling_freq_V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000:
    v4l2_mpeg_audio_sampling_freq = 2;
pub type v4l2_mpeg_audio_sampling_freq = u32;
pub const v4l2_mpeg_audio_encoding_V4L2_MPEG_AUDIO_ENCODING_LAYER_1: v4l2_mpeg_audio_encoding = 0;
pub const v4l2_mpeg_audio_encoding_V4L2_MPEG_AUDIO_ENCODING_LAYER_2: v4l2_mpeg_audio_encoding = 1;
pub const v4l2_mpeg_audio_encoding_V4L2_MPEG_AUDIO_ENCODING_LAYER_3: v4l2_mpeg_audio_encoding = 2;
pub const v4l2_mpeg_audio_encoding_V4L2_MPEG_AUDIO_ENCODING_AAC: v4l2_mpeg_audio_encoding = 3;
pub const v4l2_mpeg_audio_encoding_V4L2_MPEG_AUDIO_ENCODING_AC3: v4l2_mpeg_audio_encoding = 4;
pub type v4l2_mpeg_audio_encoding = u32;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_32K: v4l2_mpeg_audio_l1_bitrate = 0;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_64K: v4l2_mpeg_audio_l1_bitrate = 1;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_96K: v4l2_mpeg_audio_l1_bitrate = 2;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_128K: v4l2_mpeg_audio_l1_bitrate =
    3;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_160K: v4l2_mpeg_audio_l1_bitrate =
    4;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_192K: v4l2_mpeg_audio_l1_bitrate =
    5;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_224K: v4l2_mpeg_audio_l1_bitrate =
    6;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_256K: v4l2_mpeg_audio_l1_bitrate =
    7;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_288K: v4l2_mpeg_audio_l1_bitrate =
    8;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_320K: v4l2_mpeg_audio_l1_bitrate =
    9;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_352K: v4l2_mpeg_audio_l1_bitrate =
    10;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_384K: v4l2_mpeg_audio_l1_bitrate =
    11;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_416K: v4l2_mpeg_audio_l1_bitrate =
    12;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_448K: v4l2_mpeg_audio_l1_bitrate =
    13;
pub type v4l2_mpeg_audio_l1_bitrate = u32;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_32K: v4l2_mpeg_audio_l2_bitrate = 0;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_48K: v4l2_mpeg_audio_l2_bitrate = 1;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_56K: v4l2_mpeg_audio_l2_bitrate = 2;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_64K: v4l2_mpeg_audio_l2_bitrate = 3;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_80K: v4l2_mpeg_audio_l2_bitrate = 4;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_96K: v4l2_mpeg_audio_l2_bitrate = 5;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_112K: v4l2_mpeg_audio_l2_bitrate =
    6;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_128K: v4l2_mpeg_audio_l2_bitrate =
    7;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_160K: v4l2_mpeg_audio_l2_bitrate =
    8;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_192K: v4l2_mpeg_audio_l2_bitrate =
    9;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_224K: v4l2_mpeg_audio_l2_bitrate =
    10;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_256K: v4l2_mpeg_audio_l2_bitrate =
    11;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_320K: v4l2_mpeg_audio_l2_bitrate =
    12;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_384K: v4l2_mpeg_audio_l2_bitrate =
    13;
pub type v4l2_mpeg_audio_l2_bitrate = u32;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_32K: v4l2_mpeg_audio_l3_bitrate = 0;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_40K: v4l2_mpeg_audio_l3_bitrate = 1;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_48K: v4l2_mpeg_audio_l3_bitrate = 2;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_56K: v4l2_mpeg_audio_l3_bitrate = 3;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_64K: v4l2_mpeg_audio_l3_bitrate = 4;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_80K: v4l2_mpeg_audio_l3_bitrate = 5;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_96K: v4l2_mpeg_audio_l3_bitrate = 6;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_112K: v4l2_mpeg_audio_l3_bitrate =
    7;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_128K: v4l2_mpeg_audio_l3_bitrate =
    8;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_160K: v4l2_mpeg_audio_l3_bitrate =
    9;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_192K: v4l2_mpeg_audio_l3_bitrate =
    10;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_224K: v4l2_mpeg_audio_l3_bitrate =
    11;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_256K: v4l2_mpeg_audio_l3_bitrate =
    12;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_320K: v4l2_mpeg_audio_l3_bitrate =
    13;
pub type v4l2_mpeg_audio_l3_bitrate = u32;
pub const v4l2_mpeg_audio_mode_V4L2_MPEG_AUDIO_MODE_STEREO: v4l2_mpeg_audio_mode = 0;
pub const v4l2_mpeg_audio_mode_V4L2_MPEG_AUDIO_MODE_JOINT_STEREO: v4l2_mpeg_audio_mode = 1;
pub const v4l2_mpeg_audio_mode_V4L2_MPEG_AUDIO_MODE_DUAL: v4l2_mpeg_audio_mode = 2;
pub const v4l2_mpeg_audio_mode_V4L2_MPEG_AUDIO_MODE_MONO: v4l2_mpeg_audio_mode = 3;
pub type v4l2_mpeg_audio_mode = u32;
pub const v4l2_mpeg_audio_mode_extension_V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4:
    v4l2_mpeg_audio_mode_extension = 0;
pub const v4l2_mpeg_audio_mode_extension_V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8:
    v4l2_mpeg_audio_mode_extension = 1;
pub const v4l2_mpeg_audio_mode_extension_V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12:
    v4l2_mpeg_audio_mode_extension = 2;
pub const v4l2_mpeg_audio_mode_extension_V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16:
    v4l2_mpeg_audio_mode_extension = 3;
pub type v4l2_mpeg_audio_mode_extension = u32;
pub const v4l2_mpeg_audio_emphasis_V4L2_MPEG_AUDIO_EMPHASIS_NONE: v4l2_mpeg_audio_emphasis = 0;
pub const v4l2_mpeg_audio_emphasis_V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS: v4l2_mpeg_audio_emphasis =
    1;
pub const v4l2_mpeg_audio_emphasis_V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17: v4l2_mpeg_audio_emphasis = 2;
pub type v4l2_mpeg_audio_emphasis = u32;
pub const v4l2_mpeg_audio_crc_V4L2_MPEG_AUDIO_CRC_NONE: v4l2_mpeg_audio_crc = 0;
pub const v4l2_mpeg_audio_crc_V4L2_MPEG_AUDIO_CRC_CRC16: v4l2_mpeg_audio_crc = 1;
pub type v4l2_mpeg_audio_crc = u32;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_32K: v4l2_mpeg_audio_ac3_bitrate =
    0;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_40K: v4l2_mpeg_audio_ac3_bitrate =
    1;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_48K: v4l2_mpeg_audio_ac3_bitrate =
    2;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_56K: v4l2_mpeg_audio_ac3_bitrate =
    3;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_64K: v4l2_mpeg_audio_ac3_bitrate =
    4;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_80K: v4l2_mpeg_audio_ac3_bitrate =
    5;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_96K: v4l2_mpeg_audio_ac3_bitrate =
    6;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_112K:
    v4l2_mpeg_audio_ac3_bitrate = 7;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_128K:
    v4l2_mpeg_audio_ac3_bitrate = 8;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_160K:
    v4l2_mpeg_audio_ac3_bitrate = 9;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_192K:
    v4l2_mpeg_audio_ac3_bitrate = 10;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_224K:
    v4l2_mpeg_audio_ac3_bitrate = 11;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_256K:
    v4l2_mpeg_audio_ac3_bitrate = 12;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_320K:
    v4l2_mpeg_audio_ac3_bitrate = 13;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_384K:
    v4l2_mpeg_audio_ac3_bitrate = 14;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_448K:
    v4l2_mpeg_audio_ac3_bitrate = 15;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_512K:
    v4l2_mpeg_audio_ac3_bitrate = 16;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_576K:
    v4l2_mpeg_audio_ac3_bitrate = 17;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_640K:
    v4l2_mpeg_audio_ac3_bitrate = 18;
pub type v4l2_mpeg_audio_ac3_bitrate = u32;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_AUTO:
    v4l2_mpeg_audio_dec_playback = 0;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_STEREO:
    v4l2_mpeg_audio_dec_playback = 1;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_LEFT:
    v4l2_mpeg_audio_dec_playback = 2;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_RIGHT:
    v4l2_mpeg_audio_dec_playback = 3;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_MONO:
    v4l2_mpeg_audio_dec_playback = 4;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_SWAPPED_STEREO:
    v4l2_mpeg_audio_dec_playback = 5;
pub type v4l2_mpeg_audio_dec_playback = u32;
pub const v4l2_mpeg_video_encoding_V4L2_MPEG_VIDEO_ENCODING_MPEG_1: v4l2_mpeg_video_encoding = 0;
pub const v4l2_mpeg_video_encoding_V4L2_MPEG_VIDEO_ENCODING_MPEG_2: v4l2_mpeg_video_encoding = 1;
pub const v4l2_mpeg_video_encoding_V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC: v4l2_mpeg_video_encoding =
    2;
pub type v4l2_mpeg_video_encoding = u32;
pub const v4l2_mpeg_video_aspect_V4L2_MPEG_VIDEO_ASPECT_1x1: v4l2_mpeg_video_aspect = 0;
pub const v4l2_mpeg_video_aspect_V4L2_MPEG_VIDEO_ASPECT_4x3: v4l2_mpeg_video_aspect = 1;
pub const v4l2_mpeg_video_aspect_V4L2_MPEG_VIDEO_ASPECT_16x9: v4l2_mpeg_video_aspect = 2;
pub const v4l2_mpeg_video_aspect_V4L2_MPEG_VIDEO_ASPECT_221x100: v4l2_mpeg_video_aspect = 3;
pub type v4l2_mpeg_video_aspect = u32;
pub const v4l2_mpeg_video_bitrate_mode_V4L2_MPEG_VIDEO_BITRATE_MODE_VBR:
    v4l2_mpeg_video_bitrate_mode = 0;
pub const v4l2_mpeg_video_bitrate_mode_V4L2_MPEG_VIDEO_BITRATE_MODE_CBR:
    v4l2_mpeg_video_bitrate_mode = 1;
pub type v4l2_mpeg_video_bitrate_mode = u32;
pub const v4l2_mpeg_video_header_mode_V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE:
    v4l2_mpeg_video_header_mode = 0;
pub const v4l2_mpeg_video_header_mode_V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME:
    v4l2_mpeg_video_header_mode = 1;
pub type v4l2_mpeg_video_header_mode = u32;
pub const v4l2_mpeg_video_multi_slice_mode_V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE:
    v4l2_mpeg_video_multi_slice_mode = 0;
pub const v4l2_mpeg_video_multi_slice_mode_V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB:
    v4l2_mpeg_video_multi_slice_mode = 1;
pub const v4l2_mpeg_video_multi_slice_mode_V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES:
    v4l2_mpeg_video_multi_slice_mode = 2;
pub const v4l2_mpeg_video_multi_slice_mode_V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_MB:
    v4l2_mpeg_video_multi_slice_mode = 1;
pub const v4l2_mpeg_video_multi_slice_mode_V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES:
    v4l2_mpeg_video_multi_slice_mode = 2;
pub type v4l2_mpeg_video_multi_slice_mode = u32;
pub const v4l2_mpeg_video_mpeg2_level_V4L2_MPEG_VIDEO_MPEG2_LEVEL_LOW: v4l2_mpeg_video_mpeg2_level =
    0;
pub const v4l2_mpeg_video_mpeg2_level_V4L2_MPEG_VIDEO_MPEG2_LEVEL_MAIN:
    v4l2_mpeg_video_mpeg2_level = 1;
pub const v4l2_mpeg_video_mpeg2_level_V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH_1440:
    v4l2_mpeg_video_mpeg2_level = 2;
pub const v4l2_mpeg_video_mpeg2_level_V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH:
    v4l2_mpeg_video_mpeg2_level = 3;
pub type v4l2_mpeg_video_mpeg2_level = u32;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_SIMPLE:
    v4l2_mpeg_video_mpeg2_profile = 0;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_MAIN:
    v4l2_mpeg_video_mpeg2_profile = 1;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_SNR_SCALABLE:
    v4l2_mpeg_video_mpeg2_profile = 2;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_SPATIALLY_SCALABLE:
    v4l2_mpeg_video_mpeg2_profile = 3;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_HIGH:
    v4l2_mpeg_video_mpeg2_profile = 4;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_MULTIVIEW:
    v4l2_mpeg_video_mpeg2_profile = 5;
pub type v4l2_mpeg_video_mpeg2_profile = u32;
pub const v4l2_mpeg_video_h264_entropy_mode_V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC:
    v4l2_mpeg_video_h264_entropy_mode = 0;
pub const v4l2_mpeg_video_h264_entropy_mode_V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC:
    v4l2_mpeg_video_h264_entropy_mode = 1;
pub type v4l2_mpeg_video_h264_entropy_mode = u32;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_1_0: v4l2_mpeg_video_h264_level = 0;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_1B: v4l2_mpeg_video_h264_level = 1;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_1_1: v4l2_mpeg_video_h264_level = 2;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_1_2: v4l2_mpeg_video_h264_level = 3;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_1_3: v4l2_mpeg_video_h264_level = 4;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_2_0: v4l2_mpeg_video_h264_level = 5;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_2_1: v4l2_mpeg_video_h264_level = 6;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_2_2: v4l2_mpeg_video_h264_level = 7;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_3_0: v4l2_mpeg_video_h264_level = 8;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_3_1: v4l2_mpeg_video_h264_level = 9;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_3_2: v4l2_mpeg_video_h264_level =
    10;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_4_0: v4l2_mpeg_video_h264_level =
    11;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_4_1: v4l2_mpeg_video_h264_level =
    12;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_4_2: v4l2_mpeg_video_h264_level =
    13;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_5_0: v4l2_mpeg_video_h264_level =
    14;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_5_1: v4l2_mpeg_video_h264_level =
    15;
pub type v4l2_mpeg_video_h264_level = u32;
pub const v4l2_mpeg_video_h264_loop_filter_mode_V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED:
    v4l2_mpeg_video_h264_loop_filter_mode = 0;
pub const v4l2_mpeg_video_h264_loop_filter_mode_V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED:
    v4l2_mpeg_video_h264_loop_filter_mode = 1;
pub const v4l2_mpeg_video_h264_loop_filter_mode_V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY : v4l2_mpeg_video_h264_loop_filter_mode = 2 ;
pub type v4l2_mpeg_video_h264_loop_filter_mode = u32;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:
    v4l2_mpeg_video_h264_profile = 0;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE:
    v4l2_mpeg_video_h264_profile = 1;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:
    v4l2_mpeg_video_h264_profile = 2;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED:
    v4l2_mpeg_video_h264_profile = 3;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:
    v4l2_mpeg_video_h264_profile = 4;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10:
    v4l2_mpeg_video_h264_profile = 5;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422:
    v4l2_mpeg_video_h264_profile = 6;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE:
    v4l2_mpeg_video_h264_profile = 7;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10_INTRA:
    v4l2_mpeg_video_h264_profile = 8;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422_INTRA:
    v4l2_mpeg_video_h264_profile = 9;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_INTRA:
    v4l2_mpeg_video_h264_profile = 10;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_CAVLC_444_INTRA:
    v4l2_mpeg_video_h264_profile = 11;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_BASELINE:
    v4l2_mpeg_video_h264_profile = 12;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH:
    v4l2_mpeg_video_h264_profile = 13;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH_INTRA:
    v4l2_mpeg_video_h264_profile = 14;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH:
    v4l2_mpeg_video_h264_profile = 15;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH:
    v4l2_mpeg_video_h264_profile = 16;
pub type v4l2_mpeg_video_h264_profile = u32;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_UNSPECIFIED:
    v4l2_mpeg_video_h264_vui_sar_idc = 0;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1:
    v4l2_mpeg_video_h264_vui_sar_idc = 1;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_12x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 2;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_10x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 3;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_16x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 4;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_40x33:
    v4l2_mpeg_video_h264_vui_sar_idc = 5;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_24x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 6;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_20x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 7;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_32x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 8;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_80x33:
    v4l2_mpeg_video_h264_vui_sar_idc = 9;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_18x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 10;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_15x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 11;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_64x33:
    v4l2_mpeg_video_h264_vui_sar_idc = 12;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_160x99:
    v4l2_mpeg_video_h264_vui_sar_idc = 13;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_4x3:
    v4l2_mpeg_video_h264_vui_sar_idc = 14;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_3x2:
    v4l2_mpeg_video_h264_vui_sar_idc = 15;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_2x1:
    v4l2_mpeg_video_h264_vui_sar_idc = 16;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED:
    v4l2_mpeg_video_h264_vui_sar_idc = 17;
pub type v4l2_mpeg_video_h264_vui_sar_idc = u32;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_CHECKERBOARD : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 0 ;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_COLUMN : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 1 ;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_ROW : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 2 ;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_SIDE_BY_SIDE : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 3 ;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TOP_BOTTOM : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 4 ;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TEMPORAL : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 5 ;
pub type v4l2_mpeg_video_h264_sei_fp_arrangement_type = u32;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_INTERLEAVED_SLICES:
    v4l2_mpeg_video_h264_fmo_map_type = 0;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_SCATTERED_SLICES:
    v4l2_mpeg_video_h264_fmo_map_type = 1;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_FOREGROUND_WITH_LEFT_OVER : v4l2_mpeg_video_h264_fmo_map_type = 2 ;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_BOX_OUT:
    v4l2_mpeg_video_h264_fmo_map_type = 3;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_RASTER_SCAN:
    v4l2_mpeg_video_h264_fmo_map_type = 4;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_WIPE_SCAN:
    v4l2_mpeg_video_h264_fmo_map_type = 5;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_EXPLICIT:
    v4l2_mpeg_video_h264_fmo_map_type = 6;
pub type v4l2_mpeg_video_h264_fmo_map_type = u32;
pub const v4l2_mpeg_video_h264_fmo_change_dir_V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_RIGHT:
    v4l2_mpeg_video_h264_fmo_change_dir = 0;
pub const v4l2_mpeg_video_h264_fmo_change_dir_V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_LEFT:
    v4l2_mpeg_video_h264_fmo_change_dir = 1;
pub type v4l2_mpeg_video_h264_fmo_change_dir = u32;
pub const v4l2_mpeg_video_h264_hierarchical_coding_type_V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_B : v4l2_mpeg_video_h264_hierarchical_coding_type = 0 ;
pub const v4l2_mpeg_video_h264_hierarchical_coding_type_V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_P : v4l2_mpeg_video_h264_hierarchical_coding_type = 1 ;
pub type v4l2_mpeg_video_h264_hierarchical_coding_type = u32;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_0: v4l2_mpeg_video_mpeg4_level =
    0;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_0B: v4l2_mpeg_video_mpeg4_level =
    1;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_1: v4l2_mpeg_video_mpeg4_level =
    2;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_2: v4l2_mpeg_video_mpeg4_level =
    3;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_3: v4l2_mpeg_video_mpeg4_level =
    4;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_3B: v4l2_mpeg_video_mpeg4_level =
    5;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_4: v4l2_mpeg_video_mpeg4_level =
    6;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_5: v4l2_mpeg_video_mpeg4_level =
    7;
pub type v4l2_mpeg_video_mpeg4_level = u32;
pub const v4l2_mpeg_video_mpeg4_profile_V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE:
    v4l2_mpeg_video_mpeg4_profile = 0;
pub const v4l2_mpeg_video_mpeg4_profile_V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_SIMPLE:
    v4l2_mpeg_video_mpeg4_profile = 1;
pub const v4l2_mpeg_video_mpeg4_profile_V4L2_MPEG_VIDEO_MPEG4_PROFILE_CORE:
    v4l2_mpeg_video_mpeg4_profile = 2;
pub const v4l2_mpeg_video_mpeg4_profile_V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE_SCALABLE:
    v4l2_mpeg_video_mpeg4_profile = 3;
pub const v4l2_mpeg_video_mpeg4_profile_V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_CODING_EFFICIENCY:
    v4l2_mpeg_video_mpeg4_profile = 4;
pub type v4l2_mpeg_video_mpeg4_profile = u32;
pub const v4l2_vp8_num_partitions_V4L2_CID_MPEG_VIDEO_VPX_1_PARTITION: v4l2_vp8_num_partitions = 0;
pub const v4l2_vp8_num_partitions_V4L2_CID_MPEG_VIDEO_VPX_2_PARTITIONS: v4l2_vp8_num_partitions = 1;
pub const v4l2_vp8_num_partitions_V4L2_CID_MPEG_VIDEO_VPX_4_PARTITIONS: v4l2_vp8_num_partitions = 2;
pub const v4l2_vp8_num_partitions_V4L2_CID_MPEG_VIDEO_VPX_8_PARTITIONS: v4l2_vp8_num_partitions = 3;
pub type v4l2_vp8_num_partitions = u32;
pub const v4l2_vp8_num_ref_frames_V4L2_CID_MPEG_VIDEO_VPX_1_REF_FRAME: v4l2_vp8_num_ref_frames = 0;
pub const v4l2_vp8_num_ref_frames_V4L2_CID_MPEG_VIDEO_VPX_2_REF_FRAME: v4l2_vp8_num_ref_frames = 1;
pub const v4l2_vp8_num_ref_frames_V4L2_CID_MPEG_VIDEO_VPX_3_REF_FRAME: v4l2_vp8_num_ref_frames = 2;
pub type v4l2_vp8_num_ref_frames = u32;
pub const v4l2_vp8_golden_frame_sel_V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_PREV:
    v4l2_vp8_golden_frame_sel = 0;
pub const v4l2_vp8_golden_frame_sel_V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_REF_PERIOD:
    v4l2_vp8_golden_frame_sel = 1;
pub type v4l2_vp8_golden_frame_sel = u32;
pub const v4l2_mpeg_video_vp8_profile_V4L2_MPEG_VIDEO_VP8_PROFILE_0: v4l2_mpeg_video_vp8_profile =
    0;
pub const v4l2_mpeg_video_vp8_profile_V4L2_MPEG_VIDEO_VP8_PROFILE_1: v4l2_mpeg_video_vp8_profile =
    1;
pub const v4l2_mpeg_video_vp8_profile_V4L2_MPEG_VIDEO_VP8_PROFILE_2: v4l2_mpeg_video_vp8_profile =
    2;
pub const v4l2_mpeg_video_vp8_profile_V4L2_MPEG_VIDEO_VP8_PROFILE_3: v4l2_mpeg_video_vp8_profile =
    3;
pub type v4l2_mpeg_video_vp8_profile = u32;
pub const v4l2_mpeg_video_vp9_profile_V4L2_MPEG_VIDEO_VP9_PROFILE_0: v4l2_mpeg_video_vp9_profile =
    0;
pub const v4l2_mpeg_video_vp9_profile_V4L2_MPEG_VIDEO_VP9_PROFILE_1: v4l2_mpeg_video_vp9_profile =
    1;
pub const v4l2_mpeg_video_vp9_profile_V4L2_MPEG_VIDEO_VP9_PROFILE_2: v4l2_mpeg_video_vp9_profile =
    2;
pub const v4l2_mpeg_video_vp9_profile_V4L2_MPEG_VIDEO_VP9_PROFILE_3: v4l2_mpeg_video_vp9_profile =
    3;
pub type v4l2_mpeg_video_vp9_profile = u32;
pub const v4l2_mpeg_video_hevc_hier_coding_type_V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_B:
    v4l2_mpeg_video_hevc_hier_coding_type = 0;
pub const v4l2_mpeg_video_hevc_hier_coding_type_V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_P:
    v4l2_mpeg_video_hevc_hier_coding_type = 1;
pub type v4l2_mpeg_video_hevc_hier_coding_type = u32;
pub const v4l2_mpeg_video_hevc_profile_V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN:
    v4l2_mpeg_video_hevc_profile = 0;
pub const v4l2_mpeg_video_hevc_profile_V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE:
    v4l2_mpeg_video_hevc_profile = 1;
pub const v4l2_mpeg_video_hevc_profile_V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10:
    v4l2_mpeg_video_hevc_profile = 2;
pub type v4l2_mpeg_video_hevc_profile = u32;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_1: v4l2_mpeg_video_hevc_level = 0;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_2: v4l2_mpeg_video_hevc_level = 1;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1: v4l2_mpeg_video_hevc_level = 2;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_3: v4l2_mpeg_video_hevc_level = 3;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1: v4l2_mpeg_video_hevc_level = 4;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_4: v4l2_mpeg_video_hevc_level = 5;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1: v4l2_mpeg_video_hevc_level = 6;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_5: v4l2_mpeg_video_hevc_level = 7;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1: v4l2_mpeg_video_hevc_level = 8;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_5_2: v4l2_mpeg_video_hevc_level = 9;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_6: v4l2_mpeg_video_hevc_level = 10;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_6_1: v4l2_mpeg_video_hevc_level =
    11;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_6_2: v4l2_mpeg_video_hevc_level =
    12;
pub type v4l2_mpeg_video_hevc_level = u32;
pub const v4l2_mpeg_video_hevc_tier_V4L2_MPEG_VIDEO_HEVC_TIER_MAIN: v4l2_mpeg_video_hevc_tier = 0;
pub const v4l2_mpeg_video_hevc_tier_V4L2_MPEG_VIDEO_HEVC_TIER_HIGH: v4l2_mpeg_video_hevc_tier = 1;
pub type v4l2_mpeg_video_hevc_tier = u32;
pub const v4l2_cid_mpeg_video_hevc_loop_filter_mode_V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED : v4l2_cid_mpeg_video_hevc_loop_filter_mode = 0 ;
pub const v4l2_cid_mpeg_video_hevc_loop_filter_mode_V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_ENABLED : v4l2_cid_mpeg_video_hevc_loop_filter_mode = 1 ;
pub const v4l2_cid_mpeg_video_hevc_loop_filter_mode_V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY : v4l2_cid_mpeg_video_hevc_loop_filter_mode = 2 ;
pub type v4l2_cid_mpeg_video_hevc_loop_filter_mode = u32;
pub const v4l2_cid_mpeg_video_hevc_refresh_type_V4L2_MPEG_VIDEO_HEVC_REFRESH_NONE:
    v4l2_cid_mpeg_video_hevc_refresh_type = 0;
pub const v4l2_cid_mpeg_video_hevc_refresh_type_V4L2_MPEG_VIDEO_HEVC_REFRESH_CRA:
    v4l2_cid_mpeg_video_hevc_refresh_type = 1;
pub const v4l2_cid_mpeg_video_hevc_refresh_type_V4L2_MPEG_VIDEO_HEVC_REFRESH_IDR:
    v4l2_cid_mpeg_video_hevc_refresh_type = 2;
pub type v4l2_cid_mpeg_video_hevc_refresh_type = u32;
pub const v4l2_cid_mpeg_video_hevc_size_of_length_field_V4L2_MPEG_VIDEO_HEVC_SIZE_0:
    v4l2_cid_mpeg_video_hevc_size_of_length_field = 0;
pub const v4l2_cid_mpeg_video_hevc_size_of_length_field_V4L2_MPEG_VIDEO_HEVC_SIZE_1:
    v4l2_cid_mpeg_video_hevc_size_of_length_field = 1;
pub const v4l2_cid_mpeg_video_hevc_size_of_length_field_V4L2_MPEG_VIDEO_HEVC_SIZE_2:
    v4l2_cid_mpeg_video_hevc_size_of_length_field = 2;
pub const v4l2_cid_mpeg_video_hevc_size_of_length_field_V4L2_MPEG_VIDEO_HEVC_SIZE_4:
    v4l2_cid_mpeg_video_hevc_size_of_length_field = 3;
pub type v4l2_cid_mpeg_video_hevc_size_of_length_field = u32;
pub const v4l2_mpeg_cx2341x_video_spatial_filter_mode_V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL : v4l2_mpeg_cx2341x_video_spatial_filter_mode = 0 ;
pub const v4l2_mpeg_cx2341x_video_spatial_filter_mode_V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO : v4l2_mpeg_cx2341x_video_spatial_filter_mode = 1 ;
pub type v4l2_mpeg_cx2341x_video_spatial_filter_mode = u32;
pub const v4l2_mpeg_cx2341x_video_luma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF : v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = 0 ;
pub const v4l2_mpeg_cx2341x_video_luma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR : v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = 1 ;
pub const v4l2_mpeg_cx2341x_video_luma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT : v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = 2 ;
pub const v4l2_mpeg_cx2341x_video_luma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE : v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = 3 ;
pub const v4l2_mpeg_cx2341x_video_luma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE : v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = 4 ;
pub type v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = u32;
pub const v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF : v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type = 0 ;
pub const v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR : v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type = 1 ;
pub type v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type = u32;
pub const v4l2_mpeg_cx2341x_video_temporal_filter_mode_V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL : v4l2_mpeg_cx2341x_video_temporal_filter_mode = 0 ;
pub const v4l2_mpeg_cx2341x_video_temporal_filter_mode_V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO : v4l2_mpeg_cx2341x_video_temporal_filter_mode = 1 ;
pub type v4l2_mpeg_cx2341x_video_temporal_filter_mode = u32;
pub const v4l2_mpeg_cx2341x_video_median_filter_type_V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF : v4l2_mpeg_cx2341x_video_median_filter_type = 0 ;
pub const v4l2_mpeg_cx2341x_video_median_filter_type_V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR : v4l2_mpeg_cx2341x_video_median_filter_type = 1 ;
pub const v4l2_mpeg_cx2341x_video_median_filter_type_V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT : v4l2_mpeg_cx2341x_video_median_filter_type = 2 ;
pub const v4l2_mpeg_cx2341x_video_median_filter_type_V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT : v4l2_mpeg_cx2341x_video_median_filter_type = 3 ;
pub const v4l2_mpeg_cx2341x_video_median_filter_type_V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG : v4l2_mpeg_cx2341x_video_median_filter_type = 4 ;
pub type v4l2_mpeg_cx2341x_video_median_filter_type = u32;
pub const v4l2_mpeg_mfc51_video_frame_skip_mode_V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_DISABLED:
    v4l2_mpeg_mfc51_video_frame_skip_mode = 0;
pub const v4l2_mpeg_mfc51_video_frame_skip_mode_V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_LEVEL_LIMIT : v4l2_mpeg_mfc51_video_frame_skip_mode = 1 ;
pub const v4l2_mpeg_mfc51_video_frame_skip_mode_V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT:
    v4l2_mpeg_mfc51_video_frame_skip_mode = 2;
pub type v4l2_mpeg_mfc51_video_frame_skip_mode = u32;
pub const v4l2_mpeg_mfc51_video_force_frame_type_V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_DISABLED:
    v4l2_mpeg_mfc51_video_force_frame_type = 0;
pub const v4l2_mpeg_mfc51_video_force_frame_type_V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_I_FRAME:
    v4l2_mpeg_mfc51_video_force_frame_type = 1;
pub const v4l2_mpeg_mfc51_video_force_frame_type_V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_NOT_CODED : v4l2_mpeg_mfc51_video_force_frame_type = 2 ;
pub type v4l2_mpeg_mfc51_video_force_frame_type = u32;
pub const v4l2_exposure_auto_type_V4L2_EXPOSURE_AUTO: v4l2_exposure_auto_type = 0;
pub const v4l2_exposure_auto_type_V4L2_EXPOSURE_MANUAL: v4l2_exposure_auto_type = 1;
pub const v4l2_exposure_auto_type_V4L2_EXPOSURE_SHUTTER_PRIORITY: v4l2_exposure_auto_type = 2;
pub const v4l2_exposure_auto_type_V4L2_EXPOSURE_APERTURE_PRIORITY: v4l2_exposure_auto_type = 3;
pub type v4l2_exposure_auto_type = u32;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_MANUAL:
    v4l2_auto_n_preset_white_balance = 0;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_AUTO:
    v4l2_auto_n_preset_white_balance = 1;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_INCANDESCENT:
    v4l2_auto_n_preset_white_balance = 2;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_FLUORESCENT:
    v4l2_auto_n_preset_white_balance = 3;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_FLUORESCENT_H:
    v4l2_auto_n_preset_white_balance = 4;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_HORIZON:
    v4l2_auto_n_preset_white_balance = 5;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_DAYLIGHT:
    v4l2_auto_n_preset_white_balance = 6;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_FLASH:
    v4l2_auto_n_preset_white_balance = 7;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_CLOUDY:
    v4l2_auto_n_preset_white_balance = 8;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_SHADE:
    v4l2_auto_n_preset_white_balance = 9;
pub type v4l2_auto_n_preset_white_balance = u32;
pub const v4l2_iso_sensitivity_auto_type_V4L2_ISO_SENSITIVITY_MANUAL:
    v4l2_iso_sensitivity_auto_type = 0;
pub const v4l2_iso_sensitivity_auto_type_V4L2_ISO_SENSITIVITY_AUTO: v4l2_iso_sensitivity_auto_type =
    1;
pub type v4l2_iso_sensitivity_auto_type = u32;
pub const v4l2_exposure_metering_V4L2_EXPOSURE_METERING_AVERAGE: v4l2_exposure_metering = 0;
pub const v4l2_exposure_metering_V4L2_EXPOSURE_METERING_CENTER_WEIGHTED: v4l2_exposure_metering = 1;
pub const v4l2_exposure_metering_V4L2_EXPOSURE_METERING_SPOT: v4l2_exposure_metering = 2;
pub const v4l2_exposure_metering_V4L2_EXPOSURE_METERING_MATRIX: v4l2_exposure_metering = 3;
pub type v4l2_exposure_metering = u32;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_NONE: v4l2_scene_mode = 0;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_BACKLIGHT: v4l2_scene_mode = 1;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_BEACH_SNOW: v4l2_scene_mode = 2;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_CANDLE_LIGHT: v4l2_scene_mode = 3;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_DAWN_DUSK: v4l2_scene_mode = 4;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_FALL_COLORS: v4l2_scene_mode = 5;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_FIREWORKS: v4l2_scene_mode = 6;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_LANDSCAPE: v4l2_scene_mode = 7;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_NIGHT: v4l2_scene_mode = 8;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_PARTY_INDOOR: v4l2_scene_mode = 9;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_PORTRAIT: v4l2_scene_mode = 10;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_SPORTS: v4l2_scene_mode = 11;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_SUNSET: v4l2_scene_mode = 12;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_TEXT: v4l2_scene_mode = 13;
pub type v4l2_scene_mode = u32;
pub const v4l2_auto_focus_range_V4L2_AUTO_FOCUS_RANGE_AUTO: v4l2_auto_focus_range = 0;
pub const v4l2_auto_focus_range_V4L2_AUTO_FOCUS_RANGE_NORMAL: v4l2_auto_focus_range = 1;
pub const v4l2_auto_focus_range_V4L2_AUTO_FOCUS_RANGE_MACRO: v4l2_auto_focus_range = 2;
pub const v4l2_auto_focus_range_V4L2_AUTO_FOCUS_RANGE_INFINITY: v4l2_auto_focus_range = 3;
pub type v4l2_auto_focus_range = u32;
pub const v4l2_preemphasis_V4L2_PREEMPHASIS_DISABLED: v4l2_preemphasis = 0;
pub const v4l2_preemphasis_V4L2_PREEMPHASIS_50_uS: v4l2_preemphasis = 1;
pub const v4l2_preemphasis_V4L2_PREEMPHASIS_75_uS: v4l2_preemphasis = 2;
pub type v4l2_preemphasis = u32;
pub const v4l2_flash_led_mode_V4L2_FLASH_LED_MODE_NONE: v4l2_flash_led_mode = 0;
pub const v4l2_flash_led_mode_V4L2_FLASH_LED_MODE_FLASH: v4l2_flash_led_mode = 1;
pub const v4l2_flash_led_mode_V4L2_FLASH_LED_MODE_TORCH: v4l2_flash_led_mode = 2;
pub type v4l2_flash_led_mode = u32;
pub const v4l2_flash_strobe_source_V4L2_FLASH_STROBE_SOURCE_SOFTWARE: v4l2_flash_strobe_source = 0;
pub const v4l2_flash_strobe_source_V4L2_FLASH_STROBE_SOURCE_EXTERNAL: v4l2_flash_strobe_source = 1;
pub type v4l2_flash_strobe_source = u32;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_444:
    v4l2_jpeg_chroma_subsampling = 0;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_422:
    v4l2_jpeg_chroma_subsampling = 1;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_420:
    v4l2_jpeg_chroma_subsampling = 2;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_411:
    v4l2_jpeg_chroma_subsampling = 3;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_410:
    v4l2_jpeg_chroma_subsampling = 4;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY:
    v4l2_jpeg_chroma_subsampling = 5;
pub type v4l2_jpeg_chroma_subsampling = u32;
pub const v4l2_dv_tx_mode_V4L2_DV_TX_MODE_DVI_D: v4l2_dv_tx_mode = 0;
pub const v4l2_dv_tx_mode_V4L2_DV_TX_MODE_HDMI: v4l2_dv_tx_mode = 1;
pub type v4l2_dv_tx_mode = u32;
pub const v4l2_dv_rgb_range_V4L2_DV_RGB_RANGE_AUTO: v4l2_dv_rgb_range = 0;
pub const v4l2_dv_rgb_range_V4L2_DV_RGB_RANGE_LIMITED: v4l2_dv_rgb_range = 1;
pub const v4l2_dv_rgb_range_V4L2_DV_RGB_RANGE_FULL: v4l2_dv_rgb_range = 2;
pub type v4l2_dv_rgb_range = u32;
pub const v4l2_dv_it_content_type_V4L2_DV_IT_CONTENT_TYPE_GRAPHICS: v4l2_dv_it_content_type = 0;
pub const v4l2_dv_it_content_type_V4L2_DV_IT_CONTENT_TYPE_PHOTO: v4l2_dv_it_content_type = 1;
pub const v4l2_dv_it_content_type_V4L2_DV_IT_CONTENT_TYPE_CINEMA: v4l2_dv_it_content_type = 2;
pub const v4l2_dv_it_content_type_V4L2_DV_IT_CONTENT_TYPE_GAME: v4l2_dv_it_content_type = 3;
pub const v4l2_dv_it_content_type_V4L2_DV_IT_CONTENT_TYPE_NO_ITC: v4l2_dv_it_content_type = 4;
pub type v4l2_dv_it_content_type = u32;
pub const v4l2_deemphasis_V4L2_DEEMPHASIS_DISABLED: v4l2_deemphasis = 0;
pub const v4l2_deemphasis_V4L2_DEEMPHASIS_50_uS: v4l2_deemphasis = 1;
pub const v4l2_deemphasis_V4L2_DEEMPHASIS_75_uS: v4l2_deemphasis = 2;
pub type v4l2_deemphasis = u32;
pub const v4l2_detect_md_mode_V4L2_DETECT_MD_MODE_DISABLED: v4l2_detect_md_mode = 0;
pub const v4l2_detect_md_mode_V4L2_DETECT_MD_MODE_GLOBAL: v4l2_detect_md_mode = 1;
pub const v4l2_detect_md_mode_V4L2_DETECT_MD_MODE_THRESHOLD_GRID: v4l2_detect_md_mode = 2;
pub const v4l2_detect_md_mode_V4L2_DETECT_MD_MODE_REGION_GRID: v4l2_detect_md_mode = 3;
pub type v4l2_detect_md_mode = u32;
pub const v4l2_field_V4L2_FIELD_ANY: v4l2_field = 0;
pub const v4l2_field_V4L2_FIELD_NONE: v4l2_field = 1;
pub const v4l2_field_V4L2_FIELD_TOP: v4l2_field = 2;
pub const v4l2_field_V4L2_FIELD_BOTTOM: v4l2_field = 3;
pub const v4l2_field_V4L2_FIELD_INTERLACED: v4l2_field = 4;
pub const v4l2_field_V4L2_FIELD_SEQ_TB: v4l2_field = 5;
pub const v4l2_field_V4L2_FIELD_SEQ_BT: v4l2_field = 6;
pub const v4l2_field_V4L2_FIELD_ALTERNATE: v4l2_field = 7;
pub const v4l2_field_V4L2_FIELD_INTERLACED_TB: v4l2_field = 8;
pub const v4l2_field_V4L2_FIELD_INTERLACED_BT: v4l2_field = 9;
pub type v4l2_field = u32;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_CAPTURE: v4l2_buf_type = 1;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_OUTPUT: v4l2_buf_type = 2;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_OVERLAY: v4l2_buf_type = 3;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VBI_CAPTURE: v4l2_buf_type = 4;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VBI_OUTPUT: v4l2_buf_type = 5;
pub const v4l2_buf_type_V4L2_BUF_TYPE_SLICED_VBI_CAPTURE: v4l2_buf_type = 6;
pub const v4l2_buf_type_V4L2_BUF_TYPE_SLICED_VBI_OUTPUT: v4l2_buf_type = 7;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY: v4l2_buf_type = 8;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE: v4l2_buf_type = 9;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE: v4l2_buf_type = 10;
pub const v4l2_buf_type_V4L2_BUF_TYPE_SDR_CAPTURE: v4l2_buf_type = 11;
pub const v4l2_buf_type_V4L2_BUF_TYPE_SDR_OUTPUT: v4l2_buf_type = 12;
pub const v4l2_buf_type_V4L2_BUF_TYPE_META_CAPTURE: v4l2_buf_type = 13;
pub const v4l2_buf_type_V4L2_BUF_TYPE_META_OUTPUT: v4l2_buf_type = 14;
pub const v4l2_buf_type_V4L2_BUF_TYPE_PRIVATE: v4l2_buf_type = 128;
pub type v4l2_buf_type = u32;
pub const v4l2_tuner_type_V4L2_TUNER_RADIO: v4l2_tuner_type = 1;
pub const v4l2_tuner_type_V4L2_TUNER_ANALOG_TV: v4l2_tuner_type = 2;
pub const v4l2_tuner_type_V4L2_TUNER_DIGITAL_TV: v4l2_tuner_type = 3;
pub const v4l2_tuner_type_V4L2_TUNER_SDR: v4l2_tuner_type = 4;
pub const v4l2_tuner_type_V4L2_TUNER_RF: v4l2_tuner_type = 5;
pub type v4l2_tuner_type = u32;
pub const v4l2_memory_V4L2_MEMORY_MMAP: v4l2_memory = 1;
pub const v4l2_memory_V4L2_MEMORY_USERPTR: v4l2_memory = 2;
pub const v4l2_memory_V4L2_MEMORY_OVERLAY: v4l2_memory = 3;
pub const v4l2_memory_V4L2_MEMORY_DMABUF: v4l2_memory = 4;
pub type v4l2_memory = u32;
pub const v4l2_colorspace_V4L2_COLORSPACE_DEFAULT: v4l2_colorspace = 0;
pub const v4l2_colorspace_V4L2_COLORSPACE_SMPTE170M: v4l2_colorspace = 1;
pub const v4l2_colorspace_V4L2_COLORSPACE_SMPTE240M: v4l2_colorspace = 2;
pub const v4l2_colorspace_V4L2_COLORSPACE_REC709: v4l2_colorspace = 3;
pub const v4l2_colorspace_V4L2_COLORSPACE_BT878: v4l2_colorspace = 4;
pub const v4l2_colorspace_V4L2_COLORSPACE_470_SYSTEM_M: v4l2_colorspace = 5;
pub const v4l2_colorspace_V4L2_COLORSPACE_470_SYSTEM_BG: v4l2_colorspace = 6;
pub const v4l2_colorspace_V4L2_COLORSPACE_JPEG: v4l2_colorspace = 7;
pub const v4l2_colorspace_V4L2_COLORSPACE_SRGB: v4l2_colorspace = 8;
pub const v4l2_colorspace_V4L2_COLORSPACE_OPRGB: v4l2_colorspace = 9;
pub const v4l2_colorspace_V4L2_COLORSPACE_BT2020: v4l2_colorspace = 10;
pub const v4l2_colorspace_V4L2_COLORSPACE_RAW: v4l2_colorspace = 11;
pub const v4l2_colorspace_V4L2_COLORSPACE_DCI_P3: v4l2_colorspace = 12;
pub type v4l2_colorspace = u32;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_DEFAULT: v4l2_xfer_func = 0;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_709: v4l2_xfer_func = 1;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_SRGB: v4l2_xfer_func = 2;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_OPRGB: v4l2_xfer_func = 3;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_SMPTE240M: v4l2_xfer_func = 4;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_NONE: v4l2_xfer_func = 5;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_DCI_P3: v4l2_xfer_func = 6;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_SMPTE2084: v4l2_xfer_func = 7;
pub type v4l2_xfer_func = u32;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_DEFAULT: v4l2_ycbcr_encoding = 0;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_601: v4l2_ycbcr_encoding = 1;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_709: v4l2_ycbcr_encoding = 2;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_XV601: v4l2_ycbcr_encoding = 3;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_XV709: v4l2_ycbcr_encoding = 4;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_SYCC: v4l2_ycbcr_encoding = 5;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_BT2020: v4l2_ycbcr_encoding = 6;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_BT2020_CONST_LUM: v4l2_ycbcr_encoding = 7;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_SMPTE240M: v4l2_ycbcr_encoding = 8;
pub type v4l2_ycbcr_encoding = u32;
pub const v4l2_hsv_encoding_V4L2_HSV_ENC_180: v4l2_hsv_encoding = 128;
pub const v4l2_hsv_encoding_V4L2_HSV_ENC_256: v4l2_hsv_encoding = 129;
pub type v4l2_hsv_encoding = u32;
pub const v4l2_quantization_V4L2_QUANTIZATION_DEFAULT: v4l2_quantization = 0;
pub const v4l2_quantization_V4L2_QUANTIZATION_FULL_RANGE: v4l2_quantization = 1;
pub const v4l2_quantization_V4L2_QUANTIZATION_LIM_RANGE: v4l2_quantization = 2;
pub type v4l2_quantization = u32;
pub const v4l2_priority_V4L2_PRIORITY_UNSET: v4l2_priority = 0;
pub const v4l2_priority_V4L2_PRIORITY_BACKGROUND: v4l2_priority = 1;
pub const v4l2_priority_V4L2_PRIORITY_INTERACTIVE: v4l2_priority = 2;
pub const v4l2_priority_V4L2_PRIORITY_RECORD: v4l2_priority = 3;
pub const v4l2_priority_V4L2_PRIORITY_DEFAULT: v4l2_priority = 2;
pub type v4l2_priority = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_rect {
    pub left: __s32,
    pub top: __s32,
    pub width: __u32,
    pub height: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_rect() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_rect>(),
        16usize,
        concat!("Size of: ", stringify!(v4l2_rect))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_rect>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_rect>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_rect>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_rect>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_rect>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rect),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_fract {
    pub numerator: __u32,
    pub denominator: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_fract() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_fract>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_fract))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_fract>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_fract))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_fract>())).numerator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fract),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_fract>())).denominator as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fract),
            "::",
            stringify!(denominator)
        )
    );
}
#[doc = " struct v4l2_capability - Describes V4L2 device caps returned by VIDIOC_QUERYCAP"]
#[doc = ""]
#[doc = " @driver:\t   name of the driver module (e.g. \"bttv\")"]
#[doc = " @card:\t   name of the card (e.g. \"Hauppauge WinTV\")"]
#[doc = " @bus_info:\t   name of the bus (e.g. \"PCI:\" + pci_name(pci_dev) )"]
#[doc = " @version:\t   KERNEL_VERSION"]
#[doc = " @capabilities: capabilities of the physical device as a whole"]
#[doc = " @device_caps:  capabilities accessed via this particular device (node)"]
#[doc = " @reserved:\t   reserved fields for future extensions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_capability {
    pub driver: [__u8; 16usize],
    pub card: [__u8; 32usize],
    pub bus_info: [__u8; 32usize],
    pub version: __u32,
    pub capabilities: __u32,
    pub device_caps: __u32,
    pub reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_capability() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_capability>(),
        104usize,
        concat!("Size of: ", stringify!(v4l2_capability))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_capability>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_capability))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_capability>())).driver as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_capability>())).card as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(card)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_capability>())).bus_info as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(bus_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_capability>())).version as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_capability>())).capabilities as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_capability>())).device_caps as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(device_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_capability>())).reserved as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_pix_format {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub bytesperline: __u32,
    pub sizeimage: __u32,
    pub colorspace: __u32,
    pub priv_: __u32,
    pub flags: __u32,
    pub __bindgen_anon_1: v4l2_pix_format__bindgen_ty_1,
    pub quantization: __u32,
    pub xfer_func: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_pix_format__bindgen_ty_1 {
    pub ycbcr_enc: __u32,
    pub hsv_enc: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_pix_format__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_pix_format__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_pix_format__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_pix_format__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_pix_format__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_pix_format__bindgen_ty_1>())).ycbcr_enc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format__bindgen_ty_1),
            "::",
            stringify!(ycbcr_enc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_pix_format__bindgen_ty_1>())).hsv_enc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format__bindgen_ty_1),
            "::",
            stringify!(hsv_enc)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_pix_format() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_pix_format>(),
        48usize,
        concat!("Size of: ", stringify!(v4l2_pix_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_pix_format>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_pix_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format>())).pixelformat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(pixelformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format>())).field as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format>())).bytesperline as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(bytesperline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format>())).sizeimage as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(sizeimage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format>())).colorspace as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format>())).priv_ as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format>())).quantization as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(quantization)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format>())).xfer_func as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(xfer_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_fmtdesc {
    pub index: __u32,
    pub type_: __u32,
    pub flags: __u32,
    pub description: [__u8; 32usize],
    pub pixelformat: __u32,
    pub reserved: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout_v4l2_fmtdesc() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_fmtdesc>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_fmtdesc))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_fmtdesc>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_fmtdesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_fmtdesc>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_fmtdesc>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_fmtdesc>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_fmtdesc>())).description as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_fmtdesc>())).pixelformat as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(pixelformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_fmtdesc>())).reserved as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(reserved)
        )
    );
}
pub const v4l2_frmsizetypes_V4L2_FRMSIZE_TYPE_DISCRETE: v4l2_frmsizetypes = 1;
pub const v4l2_frmsizetypes_V4L2_FRMSIZE_TYPE_CONTINUOUS: v4l2_frmsizetypes = 2;
pub const v4l2_frmsizetypes_V4L2_FRMSIZE_TYPE_STEPWISE: v4l2_frmsizetypes = 3;
pub type v4l2_frmsizetypes = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_frmsize_discrete {
    pub width: __u32,
    pub height: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_frmsize_discrete() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmsize_discrete>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_frmsize_discrete))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmsize_discrete>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmsize_discrete))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmsize_discrete>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_discrete),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmsize_discrete>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_discrete),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_frmsize_stepwise {
    pub min_width: __u32,
    pub max_width: __u32,
    pub step_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
    pub step_height: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_frmsize_stepwise() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmsize_stepwise>(),
        24usize,
        concat!("Size of: ", stringify!(v4l2_frmsize_stepwise))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmsize_stepwise>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmsize_stepwise))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmsize_stepwise>())).min_width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmsize_stepwise>())).max_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_frmsize_stepwise>())).step_width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(step_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_frmsize_stepwise>())).min_height as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_frmsize_stepwise>())).max_height as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_frmsize_stepwise>())).step_height as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(step_height)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_frmsizeenum {
    pub index: __u32,
    pub pixel_format: __u32,
    pub type_: __u32,
    pub __bindgen_anon_1: v4l2_frmsizeenum__bindgen_ty_1,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_frmsizeenum__bindgen_ty_1 {
    pub discrete: v4l2_frmsize_discrete,
    pub stepwise: v4l2_frmsize_stepwise,
}
#[test]
fn bindgen_test_layout_v4l2_frmsizeenum__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmsizeenum__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(v4l2_frmsizeenum__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmsizeenum__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmsizeenum__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_frmsizeenum__bindgen_ty_1>())).discrete as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum__bindgen_ty_1),
            "::",
            stringify!(discrete)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_frmsizeenum__bindgen_ty_1>())).stepwise as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum__bindgen_ty_1),
            "::",
            stringify!(stepwise)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_frmsizeenum() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmsizeenum>(),
        44usize,
        concat!("Size of: ", stringify!(v4l2_frmsizeenum))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmsizeenum>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmsizeenum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmsizeenum>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmsizeenum>())).pixel_format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmsizeenum>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmsizeenum>())).reserved as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum),
            "::",
            stringify!(reserved)
        )
    );
}
pub const v4l2_frmivaltypes_V4L2_FRMIVAL_TYPE_DISCRETE: v4l2_frmivaltypes = 1;
pub const v4l2_frmivaltypes_V4L2_FRMIVAL_TYPE_CONTINUOUS: v4l2_frmivaltypes = 2;
pub const v4l2_frmivaltypes_V4L2_FRMIVAL_TYPE_STEPWISE: v4l2_frmivaltypes = 3;
pub type v4l2_frmivaltypes = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_frmival_stepwise {
    pub min: v4l2_fract,
    pub max: v4l2_fract,
    pub step: v4l2_fract,
}
#[test]
fn bindgen_test_layout_v4l2_frmival_stepwise() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmival_stepwise>(),
        24usize,
        concat!("Size of: ", stringify!(v4l2_frmival_stepwise))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmival_stepwise>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmival_stepwise))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmival_stepwise>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmival_stepwise),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmival_stepwise>())).max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmival_stepwise),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmival_stepwise>())).step as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmival_stepwise),
            "::",
            stringify!(step)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_frmivalenum {
    pub index: __u32,
    pub pixel_format: __u32,
    pub width: __u32,
    pub height: __u32,
    pub type_: __u32,
    pub __bindgen_anon_1: v4l2_frmivalenum__bindgen_ty_1,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_frmivalenum__bindgen_ty_1 {
    pub discrete: v4l2_fract,
    pub stepwise: v4l2_frmival_stepwise,
}
#[test]
fn bindgen_test_layout_v4l2_frmivalenum__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmivalenum__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(v4l2_frmivalenum__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmivalenum__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmivalenum__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_frmivalenum__bindgen_ty_1>())).discrete as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum__bindgen_ty_1),
            "::",
            stringify!(discrete)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_frmivalenum__bindgen_ty_1>())).stepwise as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum__bindgen_ty_1),
            "::",
            stringify!(stepwise)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_frmivalenum() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmivalenum>(),
        52usize,
        concat!("Size of: ", stringify!(v4l2_frmivalenum))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmivalenum>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmivalenum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmivalenum>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmivalenum>())).pixel_format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmivalenum>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmivalenum>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmivalenum>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frmivalenum>())).reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_timecode {
    pub type_: __u32,
    pub flags: __u32,
    pub frames: __u8,
    pub seconds: __u8,
    pub minutes: __u8,
    pub hours: __u8,
    pub userbits: [__u8; 4usize],
}
#[test]
fn bindgen_test_layout_v4l2_timecode() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_timecode>(),
        16usize,
        concat!("Size of: ", stringify!(v4l2_timecode))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_timecode>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_timecode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_timecode>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_timecode>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_timecode>())).frames as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_timecode>())).seconds as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(seconds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_timecode>())).minutes as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(minutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_timecode>())).hours as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(hours)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_timecode>())).userbits as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(userbits)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_jpegcompression {
    pub quality: ::std::os::raw::c_int,
    pub APPn: ::std::os::raw::c_int,
    pub APP_len: ::std::os::raw::c_int,
    pub APP_data: [::std::os::raw::c_char; 60usize],
    pub COM_len: ::std::os::raw::c_int,
    pub COM_data: [::std::os::raw::c_char; 60usize],
    pub jpeg_markers: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_jpegcompression() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_jpegcompression>(),
        140usize,
        concat!("Size of: ", stringify!(v4l2_jpegcompression))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_jpegcompression>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_jpegcompression))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_jpegcompression>())).quality as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_jpegcompression>())).APPn as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(APPn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_jpegcompression>())).APP_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(APP_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_jpegcompression>())).APP_data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(APP_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_jpegcompression>())).COM_len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(COM_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_jpegcompression>())).COM_data as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(COM_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_jpegcompression>())).jpeg_markers as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(jpeg_markers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_requestbuffers {
    pub count: __u32,
    pub type_: __u32,
    pub memory: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 1usize],
}
#[test]
fn bindgen_test_layout_v4l2_requestbuffers() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_requestbuffers>(),
        20usize,
        concat!("Size of: ", stringify!(v4l2_requestbuffers))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_requestbuffers>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_requestbuffers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_requestbuffers>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_requestbuffers),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_requestbuffers>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_requestbuffers),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_requestbuffers>())).memory as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_requestbuffers),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_requestbuffers>())).capabilities as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_requestbuffers),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_requestbuffers>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_requestbuffers),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct v4l2_plane - plane info for multi-planar buffers"]
#[doc = " @bytesused:\t\tnumber of bytes occupied by data in the plane (payload)"]
#[doc = " @length:\t\tsize of this plane (NOT the payload) in bytes"]
#[doc = " @mem_offset:\t\twhen memory in the associated struct v4l2_buffer is"]
#[doc = "\t\t\tV4L2_MEMORY_MMAP, equals the offset from the start of"]
#[doc = "\t\t\tthe device memory for this plane (or is a \"cookie\" that"]
#[doc = "\t\t\tshould be passed to mmap() called on the video node)"]
#[doc = " @userptr:\t\twhen memory is V4L2_MEMORY_USERPTR, a userspace pointer"]
#[doc = "\t\t\tpointing to this plane"]
#[doc = " @fd:\t\t\twhen memory is V4L2_MEMORY_DMABUF, a userspace file"]
#[doc = "\t\t\tdescriptor associated with this plane"]
#[doc = " @data_offset:\toffset in the plane to the start of data; usually 0,"]
#[doc = "\t\t\tunless there is a header in front of the data"]
#[doc = ""]
#[doc = " Multi-planar buffers consist of one or more planes, e.g. an YCbCr buffer"]
#[doc = " with two planes can have one plane for Y, and another for interleaved CbCr"]
#[doc = " components. Each plane can reside in a separate memory buffer, or even in"]
#[doc = " a completely separate memory node (e.g. in embedded devices)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_plane {
    pub bytesused: __u32,
    pub length: __u32,
    pub m: v4l2_plane__bindgen_ty_1,
    pub data_offset: __u32,
    pub reserved: [__u32; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_plane__bindgen_ty_1 {
    pub mem_offset: __u32,
    pub userptr: ::std::os::raw::c_ulong,
    pub fd: __s32,
}
#[test]
fn bindgen_test_layout_v4l2_plane__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_plane__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_plane__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_plane__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_plane__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_plane__bindgen_ty_1>())).mem_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane__bindgen_ty_1),
            "::",
            stringify!(mem_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_plane__bindgen_ty_1>())).userptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane__bindgen_ty_1),
            "::",
            stringify!(userptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_plane__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_plane() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_plane>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_plane))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_plane>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_plane))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_plane>())).bytesused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane),
            "::",
            stringify!(bytesused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_plane>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_plane>())).m as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_plane>())).data_offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_plane>())).reserved as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct v4l2_buffer - video buffer info"]
#[doc = " @index:\tid number of the buffer"]
#[doc = " @type:\tenum v4l2_buf_type; buffer type (type == *_MPLANE for"]
#[doc = "\t\tmultiplanar buffers);"]
#[doc = " @bytesused:\tnumber of bytes occupied by data in the buffer (payload);"]
#[doc = "\t\tunused (set to 0) for multiplanar buffers"]
#[doc = " @flags:\tbuffer informational flags"]
#[doc = " @field:\tenum v4l2_field; field order of the image in the buffer"]
#[doc = " @timestamp:\tframe timestamp"]
#[doc = " @timecode:\tframe timecode"]
#[doc = " @sequence:\tsequence count of this frame"]
#[doc = " @memory:\tenum v4l2_memory; the method, in which the actual video data is"]
#[doc = "\t\tpassed"]
#[doc = " @offset:\tfor non-multiplanar buffers with memory == V4L2_MEMORY_MMAP;"]
#[doc = "\t\toffset from the start of the device memory for this plane,"]
#[doc = "\t\t(or a \"cookie\" that should be passed to mmap() as offset)"]
#[doc = " @userptr:\tfor non-multiplanar buffers with memory == V4L2_MEMORY_USERPTR;"]
#[doc = "\t\ta userspace pointer pointing to this buffer"]
#[doc = " @fd:\t\tfor non-multiplanar buffers with memory == V4L2_MEMORY_DMABUF;"]
#[doc = "\t\ta userspace file descriptor associated with this buffer"]
#[doc = " @planes:\tfor multiplanar buffers; userspace pointer to the array of plane"]
#[doc = "\t\tinfo structs for this buffer"]
#[doc = " @length:\tsize in bytes of the buffer (NOT its payload) for single-plane"]
#[doc = "\t\tbuffers (when type != *_MPLANE); number of elements in the"]
#[doc = "\t\tplanes array for multi-plane buffers"]
#[doc = " @request_fd: fd of the request that this buffer should use"]
#[doc = ""]
#[doc = " Contains data exchanged by application and driver using one of the Streaming"]
#[doc = " I/O methods."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_buffer {
    pub index: __u32,
    pub type_: __u32,
    pub bytesused: __u32,
    pub flags: __u32,
    pub field: __u32,
    pub timestamp: timeval,
    pub timecode: v4l2_timecode,
    pub sequence: __u32,
    pub memory: __u32,
    pub m: v4l2_buffer__bindgen_ty_1,
    pub length: __u32,
    pub reserved2: __u32,
    pub __bindgen_anon_1: v4l2_buffer__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_buffer__bindgen_ty_1 {
    pub offset: __u32,
    pub userptr: ::std::os::raw::c_ulong,
    pub planes: *mut v4l2_plane,
    pub fd: __s32,
}
#[test]
fn bindgen_test_layout_v4l2_buffer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_buffer__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_buffer__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_buffer__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_buffer__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_buffer__bindgen_ty_1>())).offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_1),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_buffer__bindgen_ty_1>())).userptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_1),
            "::",
            stringify!(userptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_buffer__bindgen_ty_1>())).planes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_1),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_buffer__bindgen_ty_2 {
    pub request_fd: __s32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_buffer__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_buffer__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_buffer__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_buffer__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_buffer__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_buffer__bindgen_ty_2>())).request_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_2),
            "::",
            stringify!(request_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_buffer__bindgen_ty_2>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_buffer() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_buffer>(),
        88usize,
        concat!("Size of: ", stringify!(v4l2_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).bytesused as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(bytesused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).field as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).timestamp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).timecode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(timecode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).sequence as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).memory as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).m as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).length as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_buffer>())).reserved2 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " struct v4l2_exportbuffer - export of video buffer as DMABUF file descriptor"]
#[doc = ""]
#[doc = " @index:\tid number of the buffer"]
#[doc = " @type:\tenum v4l2_buf_type; buffer type (type == *_MPLANE for"]
#[doc = "\t\tmultiplanar buffers);"]
#[doc = " @plane:\tindex of the plane to be exported, 0 for single plane queues"]
#[doc = " @flags:\tflags for newly created file, currently only O_CLOEXEC is"]
#[doc = "\t\tsupported, refer to manual of open syscall for more details"]
#[doc = " @fd:\t\tfile descriptor associated with DMABUF (set by driver)"]
#[doc = ""]
#[doc = " Contains data used for exporting a video buffer as DMABUF file descriptor."]
#[doc = " The buffer is identified by a 'cookie' returned by VIDIOC_QUERYBUF"]
#[doc = " (identical to the cookie used to mmap() the buffer to userspace). All"]
#[doc = " reserved fields must be set to zero. The field reserved0 is expected to"]
#[doc = " become a structure 'type' allowing an alternative layout of the structure"]
#[doc = " content. Therefore this field should not be used for any other extensions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_exportbuffer {
    pub type_: __u32,
    pub index: __u32,
    pub plane: __u32,
    pub flags: __u32,
    pub fd: __s32,
    pub reserved: [__u32; 11usize],
}
#[test]
fn bindgen_test_layout_v4l2_exportbuffer() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_exportbuffer>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_exportbuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_exportbuffer>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_exportbuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_exportbuffer>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_exportbuffer>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_exportbuffer>())).plane as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(plane)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_exportbuffer>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_exportbuffer>())).fd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_exportbuffer>())).reserved as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_framebuffer {
    pub capability: __u32,
    pub flags: __u32,
    pub base: *mut ::std::os::raw::c_void,
    pub fmt: v4l2_framebuffer__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_framebuffer__bindgen_ty_1 {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub bytesperline: __u32,
    pub sizeimage: __u32,
    pub colorspace: __u32,
    pub priv_: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_framebuffer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_framebuffer__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_framebuffer__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_framebuffer__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_framebuffer__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_framebuffer__bindgen_ty_1>())).width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_framebuffer__bindgen_ty_1>())).height as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_framebuffer__bindgen_ty_1>())).pixelformat as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(pixelformat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_framebuffer__bindgen_ty_1>())).field as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_framebuffer__bindgen_ty_1>())).bytesperline as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(bytesperline)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_framebuffer__bindgen_ty_1>())).sizeimage as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(sizeimage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_framebuffer__bindgen_ty_1>())).colorspace as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_framebuffer__bindgen_ty_1>())).priv_ as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(priv_)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_framebuffer() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_framebuffer>(),
        48usize,
        concat!("Size of: ", stringify!(v4l2_framebuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_framebuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_framebuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_framebuffer>())).capability as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_framebuffer>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_framebuffer>())).base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_framebuffer>())).fmt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer),
            "::",
            stringify!(fmt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_clip {
    pub c: v4l2_rect,
    pub next: *mut v4l2_clip,
}
#[test]
fn bindgen_test_layout_v4l2_clip() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_clip>(),
        24usize,
        concat!("Size of: ", stringify!(v4l2_clip))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_clip>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_clip))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_clip>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_clip),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_clip>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_clip),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_window {
    pub w: v4l2_rect,
    pub field: __u32,
    pub chromakey: __u32,
    pub clips: *mut v4l2_clip,
    pub clipcount: __u32,
    pub bitmap: *mut ::std::os::raw::c_void,
    pub global_alpha: __u8,
}
#[test]
fn bindgen_test_layout_v4l2_window() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_window>(),
        56usize,
        concat!("Size of: ", stringify!(v4l2_window))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_window>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_window))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_window>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_window>())).field as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_window>())).chromakey as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(chromakey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_window>())).clips as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(clips)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_window>())).clipcount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(clipcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_window>())).bitmap as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_window>())).global_alpha as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(global_alpha)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_captureparm {
    pub capability: __u32,
    pub capturemode: __u32,
    pub timeperframe: v4l2_fract,
    pub extendedmode: __u32,
    pub readbuffers: __u32,
    pub reserved: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout_v4l2_captureparm() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_captureparm>(),
        40usize,
        concat!("Size of: ", stringify!(v4l2_captureparm))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_captureparm>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_captureparm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_captureparm>())).capability as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_captureparm>())).capturemode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(capturemode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_captureparm>())).timeperframe as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(timeperframe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_captureparm>())).extendedmode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(extendedmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_captureparm>())).readbuffers as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(readbuffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_captureparm>())).reserved as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_outputparm {
    pub capability: __u32,
    pub outputmode: __u32,
    pub timeperframe: v4l2_fract,
    pub extendedmode: __u32,
    pub writebuffers: __u32,
    pub reserved: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout_v4l2_outputparm() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_outputparm>(),
        40usize,
        concat!("Size of: ", stringify!(v4l2_outputparm))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_outputparm>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_outputparm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_outputparm>())).capability as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_outputparm>())).outputmode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(outputmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_outputparm>())).timeperframe as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(timeperframe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_outputparm>())).extendedmode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(extendedmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_outputparm>())).writebuffers as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(writebuffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_outputparm>())).reserved as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_cropcap {
    pub type_: __u32,
    pub bounds: v4l2_rect,
    pub defrect: v4l2_rect,
    pub pixelaspect: v4l2_fract,
}
#[test]
fn bindgen_test_layout_v4l2_cropcap() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_cropcap>(),
        44usize,
        concat!("Size of: ", stringify!(v4l2_cropcap))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_cropcap>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_cropcap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_cropcap>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_cropcap),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_cropcap>())).bounds as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_cropcap),
            "::",
            stringify!(bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_cropcap>())).defrect as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_cropcap),
            "::",
            stringify!(defrect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_cropcap>())).pixelaspect as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_cropcap),
            "::",
            stringify!(pixelaspect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_crop {
    pub type_: __u32,
    pub c: v4l2_rect,
}
#[test]
fn bindgen_test_layout_v4l2_crop() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_crop>(),
        20usize,
        concat!("Size of: ", stringify!(v4l2_crop))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_crop>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_crop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_crop>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_crop),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_crop>())).c as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_crop),
            "::",
            stringify!(c)
        )
    );
}
#[doc = " struct v4l2_selection - selection info"]
#[doc = " @type:\tbuffer type (do not use *_MPLANE types)"]
#[doc = " @target:\tSelection target, used to choose one of possible rectangles;"]
#[doc = "\t\tdefined in v4l2-common.h; V4L2_SEL_TGT_* ."]
#[doc = " @flags:\tconstraints flags, defined in v4l2-common.h; V4L2_SEL_FLAG_*."]
#[doc = " @r:\t\tcoordinates of selection window"]
#[doc = " @reserved:\tfor future use, rounds structure size to 64 bytes, set to zero"]
#[doc = ""]
#[doc = " Hardware may use multiple helper windows to process a video stream."]
#[doc = " The structure is used to exchange this selection areas between"]
#[doc = " an application and a driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_selection {
    pub type_: __u32,
    pub target: __u32,
    pub flags: __u32,
    pub r: v4l2_rect,
    pub reserved: [__u32; 9usize],
}
#[test]
fn bindgen_test_layout_v4l2_selection() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_selection>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_selection))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_selection>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_selection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_selection>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_selection),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_selection>())).target as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_selection),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_selection>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_selection),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_selection>())).r as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_selection),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_selection>())).reserved as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_selection),
            "::",
            stringify!(reserved)
        )
    );
}
pub type v4l2_std_id = __u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_standard {
    pub index: __u32,
    pub id: v4l2_std_id,
    pub name: [__u8; 24usize],
    pub frameperiod: v4l2_fract,
    pub framelines: __u32,
    pub reserved: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout_v4l2_standard() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_standard>(),
        72usize,
        concat!("Size of: ", stringify!(v4l2_standard))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_standard>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_standard))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_standard>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_standard>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_standard>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_standard>())).frameperiod as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(frameperiod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_standard>())).framelines as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(framelines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_standard>())).reserved as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct v4l2_bt_timings - BT.656/BT.1120 timing data"]
#[doc = " @width:\ttotal width of the active video in pixels"]
#[doc = " @height:\ttotal height of the active video in lines"]
#[doc = " @interlaced:\tInterlaced or progressive"]
#[doc = " @polarities:\tPositive or negative polarities"]
#[doc = " @pixelclock:\tPixel clock in HZ. Ex. 74.25MHz->74250000"]
#[doc = " @hfrontporch:Horizontal front porch in pixels"]
#[doc = " @hsync:\tHorizontal Sync length in pixels"]
#[doc = " @hbackporch:\tHorizontal back porch in pixels"]
#[doc = " @vfrontporch:Vertical front porch in lines"]
#[doc = " @vsync:\tVertical Sync length in lines"]
#[doc = " @vbackporch:\tVertical back porch in lines"]
#[doc = " @il_vfrontporch:Vertical front porch for the even field"]
#[doc = "\t\t(aka field 2) of interlaced field formats"]
#[doc = " @il_vsync:\tVertical Sync length for the even field"]
#[doc = "\t\t(aka field 2) of interlaced field formats"]
#[doc = " @il_vbackporch:Vertical back porch for the even field"]
#[doc = "\t\t(aka field 2) of interlaced field formats"]
#[doc = " @standards:\tStandards the timing belongs to"]
#[doc = " @flags:\tFlags"]
#[doc = " @picture_aspect: The picture aspect ratio (hor/vert)."]
#[doc = " @cea861_vic:\tVIC code as per the CEA-861 standard."]
#[doc = " @hdmi_vic:\tVIC code as per the HDMI standard."]
#[doc = " @reserved:\tReserved fields, must be zeroed."]
#[doc = ""]
#[doc = " A note regarding vertical interlaced timings: height refers to the total"]
#[doc = " height of the active video frame (= two fields). The blanking timings refer"]
#[doc = " to the blanking of each field. So the height of the total frame is"]
#[doc = " calculated as follows:"]
#[doc = ""]
#[doc = " tot_height = height + vfrontporch + vsync + vbackporch +"]
#[doc = "                       il_vfrontporch + il_vsync + il_vbackporch"]
#[doc = ""]
#[doc = " The active height of each field is height / 2."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_bt_timings {
    pub width: __u32,
    pub height: __u32,
    pub interlaced: __u32,
    pub polarities: __u32,
    pub pixelclock: __u64,
    pub hfrontporch: __u32,
    pub hsync: __u32,
    pub hbackporch: __u32,
    pub vfrontporch: __u32,
    pub vsync: __u32,
    pub vbackporch: __u32,
    pub il_vfrontporch: __u32,
    pub il_vsync: __u32,
    pub il_vbackporch: __u32,
    pub standards: __u32,
    pub flags: __u32,
    pub picture_aspect: v4l2_fract,
    pub cea861_vic: __u8,
    pub hdmi_vic: __u8,
    pub reserved: [__u8; 46usize],
}
#[test]
fn bindgen_test_layout_v4l2_bt_timings() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_bt_timings>(),
        124usize,
        concat!("Size of: ", stringify!(v4l2_bt_timings))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_bt_timings>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_bt_timings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).interlaced as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(interlaced)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).polarities as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(polarities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).pixelclock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(pixelclock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).hfrontporch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(hfrontporch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).hsync as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(hsync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).hbackporch as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(hbackporch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).vfrontporch as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(vfrontporch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).vsync as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(vsync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).vbackporch as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(vbackporch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).il_vfrontporch as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(il_vfrontporch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).il_vsync as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(il_vsync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).il_vbackporch as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(il_vbackporch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).standards as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(standards)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).picture_aspect as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(picture_aspect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).cea861_vic as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(cea861_vic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).hdmi_vic as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(hdmi_vic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings>())).reserved as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct v4l2_dv_timings - DV timings"]
#[doc = " @type:\tthe type of the timings"]
#[doc = " @bt:\tBT656/1120 timings"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dv_timings {
    pub type_: __u32,
    pub __bindgen_anon_1: v4l2_dv_timings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dv_timings__bindgen_ty_1 {
    pub bt: v4l2_bt_timings,
    pub reserved: [__u32; 32usize],
}
#[test]
fn bindgen_test_layout_v4l2_dv_timings__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_dv_timings__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(v4l2_dv_timings__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dv_timings__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_dv_timings__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_dv_timings__bindgen_ty_1>())).bt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings__bindgen_ty_1),
            "::",
            stringify!(bt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_dv_timings__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_dv_timings() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_dv_timings>(),
        132usize,
        concat!("Size of: ", stringify!(v4l2_dv_timings))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dv_timings>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_dv_timings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dv_timings>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " struct v4l2_enum_dv_timings - DV timings enumeration"]
#[doc = " @index:\tenumeration index"]
#[doc = " @pad:\tthe pad number for which to enumerate timings (used with"]
#[doc = "\t\tv4l-subdev nodes only)"]
#[doc = " @reserved:\tmust be zeroed"]
#[doc = " @timings:\tthe timings for the given index"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_enum_dv_timings {
    pub index: __u32,
    pub pad: __u32,
    pub reserved: [__u32; 2usize],
    pub timings: v4l2_dv_timings,
}
#[test]
fn bindgen_test_layout_v4l2_enum_dv_timings() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_enum_dv_timings>(),
        148usize,
        concat!("Size of: ", stringify!(v4l2_enum_dv_timings))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_enum_dv_timings>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_enum_dv_timings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enum_dv_timings>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enum_dv_timings),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enum_dv_timings>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enum_dv_timings),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enum_dv_timings>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enum_dv_timings),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enum_dv_timings>())).timings as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enum_dv_timings),
            "::",
            stringify!(timings)
        )
    );
}
#[doc = " struct v4l2_bt_timings_cap - BT.656/BT.1120 timing capabilities"]
#[doc = " @min_width:\t\twidth in pixels"]
#[doc = " @max_width:\t\twidth in pixels"]
#[doc = " @min_height:\t\theight in lines"]
#[doc = " @max_height:\t\theight in lines"]
#[doc = " @min_pixelclock:\tPixel clock in HZ. Ex. 74.25MHz->74250000"]
#[doc = " @max_pixelclock:\tPixel clock in HZ. Ex. 74.25MHz->74250000"]
#[doc = " @standards:\t\tSupported standards"]
#[doc = " @capabilities:\tSupported capabilities"]
#[doc = " @reserved:\t\tMust be zeroed"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_bt_timings_cap {
    pub min_width: __u32,
    pub max_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
    pub min_pixelclock: __u64,
    pub max_pixelclock: __u64,
    pub standards: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 16usize],
}
#[test]
fn bindgen_test_layout_v4l2_bt_timings_cap() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_bt_timings_cap>(),
        104usize,
        concat!("Size of: ", stringify!(v4l2_bt_timings_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_bt_timings_cap>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_bt_timings_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings_cap>())).min_width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings_cap>())).max_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings_cap>())).min_height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings_cap>())).max_height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_bt_timings_cap>())).min_pixelclock as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(min_pixelclock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_bt_timings_cap>())).max_pixelclock as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(max_pixelclock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings_cap>())).standards as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(standards)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_bt_timings_cap>())).capabilities as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_bt_timings_cap>())).reserved as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct v4l2_dv_timings_cap - DV timings capabilities"]
#[doc = " @type:\tthe type of the timings (same as in struct v4l2_dv_timings)"]
#[doc = " @pad:\tthe pad number for which to query capabilities (used with"]
#[doc = "\t\tv4l-subdev nodes only)"]
#[doc = " @bt:\t\tthe BT656/1120 timings capabilities"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_dv_timings_cap {
    pub type_: __u32,
    pub pad: __u32,
    pub reserved: [__u32; 2usize],
    pub __bindgen_anon_1: v4l2_dv_timings_cap__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dv_timings_cap__bindgen_ty_1 {
    pub bt: v4l2_bt_timings_cap,
    pub raw_data: [__u32; 32usize],
}
#[test]
fn bindgen_test_layout_v4l2_dv_timings_cap__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_dv_timings_cap__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(v4l2_dv_timings_cap__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dv_timings_cap__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_dv_timings_cap__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_dv_timings_cap__bindgen_ty_1>())).bt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings_cap__bindgen_ty_1),
            "::",
            stringify!(bt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_dv_timings_cap__bindgen_ty_1>())).raw_data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings_cap__bindgen_ty_1),
            "::",
            stringify!(raw_data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_dv_timings_cap() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_dv_timings_cap>(),
        144usize,
        concat!("Size of: ", stringify!(v4l2_dv_timings_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dv_timings_cap>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_dv_timings_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dv_timings_cap>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings_cap),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dv_timings_cap>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings_cap),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dv_timings_cap>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings_cap),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_input {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub audioset: __u32,
    pub tuner: __u32,
    pub std: v4l2_std_id,
    pub status: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_input() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_input>(),
        80usize,
        concat!("Size of: ", stringify!(v4l2_input))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_input>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_input))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_input>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_input>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_input>())).type_ as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_input>())).audioset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(audioset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_input>())).tuner as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(tuner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_input>())).std as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(std)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_input>())).status as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_input>())).capabilities as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_input>())).reserved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_output {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub audioset: __u32,
    pub modulator: __u32,
    pub std: v4l2_std_id,
    pub capabilities: __u32,
    pub reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_output() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_output>(),
        72usize,
        concat!("Size of: ", stringify!(v4l2_output))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_output>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_output))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_output>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_output>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_output>())).type_ as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_output>())).audioset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(audioset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_output>())).modulator as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(modulator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_output>())).std as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(std)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_output>())).capabilities as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_output>())).reserved as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_control {
    pub id: __u32,
    pub value: __s32,
}
#[test]
fn bindgen_test_layout_v4l2_control() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_control>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_control))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_control>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_control))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_control>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_control),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_control>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_control),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_ext_control {
    pub id: __u32,
    pub size: __u32,
    pub reserved2: [__u32; 1usize],
    pub __bindgen_anon_1: v4l2_ext_control__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_ext_control__bindgen_ty_1 {
    pub value: __s32,
    pub value64: __s64,
    pub string: *mut ::std::os::raw::c_char,
    pub p_u8: *mut __u8,
    pub p_u16: *mut __u16,
    pub p_u32: *mut __u32,
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_v4l2_ext_control__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_ext_control__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_ext_control__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ext_control__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_ext_control__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_ext_control__bindgen_ty_1>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_ext_control__bindgen_ty_1>())).value64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(value64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_ext_control__bindgen_ty_1>())).string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_ext_control__bindgen_ty_1>())).p_u8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_u8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_ext_control__bindgen_ty_1>())).p_u16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_u16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_ext_control__bindgen_ty_1>())).p_u32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_u32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_ext_control__bindgen_ty_1>())).ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_ext_control() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_ext_control>(),
        20usize,
        concat!("Size of: ", stringify!(v4l2_ext_control))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ext_control>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_ext_control))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_ext_control>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_ext_control>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_ext_control>())).reserved2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_ext_controls {
    pub __bindgen_anon_1: v4l2_ext_controls__bindgen_ty_1,
    pub count: __u32,
    pub error_idx: __u32,
    pub request_fd: __s32,
    pub reserved: [__u32; 1usize],
    pub controls: *mut v4l2_ext_control,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_ext_controls__bindgen_ty_1 {
    pub ctrl_class: __u32,
    pub which: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_ext_controls__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_ext_controls__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_ext_controls__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ext_controls__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_ext_controls__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_ext_controls__bindgen_ty_1>())).ctrl_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls__bindgen_ty_1),
            "::",
            stringify!(ctrl_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_ext_controls__bindgen_ty_1>())).which as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls__bindgen_ty_1),
            "::",
            stringify!(which)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_ext_controls() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_ext_controls>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_ext_controls))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ext_controls>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_ext_controls))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_ext_controls>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_ext_controls>())).error_idx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls),
            "::",
            stringify!(error_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_ext_controls>())).request_fd as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls),
            "::",
            stringify!(request_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_ext_controls>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_ext_controls>())).controls as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls),
            "::",
            stringify!(controls)
        )
    );
}
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_INTEGER: v4l2_ctrl_type = 1;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_BOOLEAN: v4l2_ctrl_type = 2;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_MENU: v4l2_ctrl_type = 3;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_BUTTON: v4l2_ctrl_type = 4;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_INTEGER64: v4l2_ctrl_type = 5;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_CTRL_CLASS: v4l2_ctrl_type = 6;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_STRING: v4l2_ctrl_type = 7;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_BITMASK: v4l2_ctrl_type = 8;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_INTEGER_MENU: v4l2_ctrl_type = 9;
pub const v4l2_ctrl_type_V4L2_CTRL_COMPOUND_TYPES: v4l2_ctrl_type = 256;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_U8: v4l2_ctrl_type = 256;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_U16: v4l2_ctrl_type = 257;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_U32: v4l2_ctrl_type = 258;
pub type v4l2_ctrl_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_queryctrl {
    pub id: __u32,
    pub type_: __u32,
    pub name: [__u8; 32usize],
    pub minimum: __s32,
    pub maximum: __s32,
    pub step: __s32,
    pub default_value: __s32,
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_queryctrl() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_queryctrl>(),
        68usize,
        concat!("Size of: ", stringify!(v4l2_queryctrl))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_queryctrl>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_queryctrl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_queryctrl>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_queryctrl>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_queryctrl>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_queryctrl>())).minimum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_queryctrl>())).maximum as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_queryctrl>())).step as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_queryctrl>())).default_value as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_queryctrl>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_queryctrl>())).reserved as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_query_ext_ctrl {
    pub id: __u32,
    pub type_: __u32,
    pub name: [::std::os::raw::c_char; 32usize],
    pub minimum: __s64,
    pub maximum: __s64,
    pub step: __u64,
    pub default_value: __s64,
    pub flags: __u32,
    pub elem_size: __u32,
    pub elems: __u32,
    pub nr_of_dims: __u32,
    pub dims: [__u32; 4usize],
    pub reserved: [__u32; 32usize],
}
#[test]
fn bindgen_test_layout_v4l2_query_ext_ctrl() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_query_ext_ctrl>(),
        232usize,
        concat!("Size of: ", stringify!(v4l2_query_ext_ctrl))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_query_ext_ctrl>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_query_ext_ctrl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).minimum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).maximum as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).step as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).default_value as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).flags as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).elem_size as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).elems as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).nr_of_dims as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(nr_of_dims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).dims as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_query_ext_ctrl>())).reserved as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_querymenu {
    pub id: __u32,
    pub index: __u32,
    pub __bindgen_anon_1: v4l2_querymenu__bindgen_ty_1,
    pub reserved: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_querymenu__bindgen_ty_1 {
    pub name: [__u8; 32usize],
    pub value: __s64,
}
#[test]
fn bindgen_test_layout_v4l2_querymenu__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_querymenu__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_querymenu__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_querymenu__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_querymenu__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_querymenu__bindgen_ty_1>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_querymenu__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_querymenu__bindgen_ty_1>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_querymenu__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_querymenu() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_querymenu>(),
        44usize,
        concat!("Size of: ", stringify!(v4l2_querymenu))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_querymenu>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_querymenu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_querymenu>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_querymenu),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_querymenu>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_querymenu),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_querymenu>())).reserved as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_querymenu),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_tuner {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub rxsubchans: __u32,
    pub audmode: __u32,
    pub signal: __s32,
    pub afc: __s32,
    pub reserved: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout_v4l2_tuner() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_tuner>(),
        84usize,
        concat!("Size of: ", stringify!(v4l2_tuner))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_tuner>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_tuner))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_tuner>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_tuner>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_tuner>())).type_ as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_tuner>())).capability as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_tuner>())).rangelow as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(rangelow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_tuner>())).rangehigh as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(rangehigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_tuner>())).rxsubchans as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(rxsubchans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_tuner>())).audmode as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(audmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_tuner>())).signal as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_tuner>())).afc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(afc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_tuner>())).reserved as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_modulator {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub txsubchans: __u32,
    pub type_: __u32,
    pub reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_modulator() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_modulator>(),
        68usize,
        concat!("Size of: ", stringify!(v4l2_modulator))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_modulator>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_modulator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_modulator>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_modulator>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_modulator>())).capability as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_modulator>())).rangelow as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(rangelow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_modulator>())).rangehigh as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(rangehigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_modulator>())).txsubchans as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(txsubchans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_modulator>())).type_ as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_modulator>())).reserved as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_frequency {
    pub tuner: __u32,
    pub type_: __u32,
    pub frequency: __u32,
    pub reserved: [__u32; 8usize],
}
#[test]
fn bindgen_test_layout_v4l2_frequency() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_frequency>(),
        44usize,
        concat!("Size of: ", stringify!(v4l2_frequency))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frequency>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frequency))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency>())).tuner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency),
            "::",
            stringify!(tuner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency>())).frequency as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_frequency_band {
    pub tuner: __u32,
    pub type_: __u32,
    pub index: __u32,
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub modulation: __u32,
    pub reserved: [__u32; 9usize],
}
#[test]
fn bindgen_test_layout_v4l2_frequency_band() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_frequency_band>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_frequency_band))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frequency_band>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frequency_band))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency_band>())).tuner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(tuner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency_band>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency_band>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency_band>())).capability as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency_band>())).rangelow as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(rangelow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency_band>())).rangehigh as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(rangehigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency_band>())).modulation as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(modulation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_frequency_band>())).reserved as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_hw_freq_seek {
    pub tuner: __u32,
    pub type_: __u32,
    pub seek_upward: __u32,
    pub wrap_around: __u32,
    pub spacing: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub reserved: [__u32; 5usize],
}
#[test]
fn bindgen_test_layout_v4l2_hw_freq_seek() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_hw_freq_seek>(),
        48usize,
        concat!("Size of: ", stringify!(v4l2_hw_freq_seek))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_hw_freq_seek>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_hw_freq_seek))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_hw_freq_seek>())).tuner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(tuner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_hw_freq_seek>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_hw_freq_seek>())).seek_upward as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(seek_upward)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_hw_freq_seek>())).wrap_around as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(wrap_around)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_hw_freq_seek>())).spacing as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(spacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_hw_freq_seek>())).rangelow as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(rangelow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_hw_freq_seek>())).rangehigh as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(rangehigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_hw_freq_seek>())).reserved as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_rds_data {
    pub lsb: __u8,
    pub msb: __u8,
    pub block: __u8,
}
#[test]
fn bindgen_test_layout_v4l2_rds_data() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_rds_data>(),
        3usize,
        concat!("Size of: ", stringify!(v4l2_rds_data))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_rds_data>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_rds_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_rds_data>())).lsb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rds_data),
            "::",
            stringify!(lsb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_rds_data>())).msb as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rds_data),
            "::",
            stringify!(msb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_rds_data>())).block as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rds_data),
            "::",
            stringify!(block)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_audio {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub mode: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_audio() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_audio>(),
        52usize,
        concat!("Size of: ", stringify!(v4l2_audio))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_audio>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_audio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_audio>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audio),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_audio>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audio),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_audio>())).capability as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audio),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_audio>())).mode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audio),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_audio>())).reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audio),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_audioout {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub mode: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_audioout() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_audioout>(),
        52usize,
        concat!("Size of: ", stringify!(v4l2_audioout))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_audioout>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_audioout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_audioout>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audioout),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_audioout>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audioout),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_audioout>())).capability as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audioout),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_audioout>())).mode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audioout),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_audioout>())).reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audioout),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_enc_idx_entry {
    pub offset: __u64,
    pub pts: __u64,
    pub length: __u32,
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_enc_idx_entry() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_enc_idx_entry>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_enc_idx_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_enc_idx_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_enc_idx_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enc_idx_entry>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx_entry),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enc_idx_entry>())).pts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx_entry),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enc_idx_entry>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx_entry),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enc_idx_entry>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx_entry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enc_idx_entry>())).reserved as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx_entry),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_enc_idx {
    pub entries: __u32,
    pub entries_cap: __u32,
    pub reserved: [__u32; 4usize],
    pub entry: [v4l2_enc_idx_entry; 64usize],
}
#[test]
fn bindgen_test_layout_v4l2_enc_idx() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_enc_idx>(),
        2072usize,
        concat!("Size of: ", stringify!(v4l2_enc_idx))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_enc_idx>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_enc_idx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enc_idx>())).entries as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enc_idx>())).entries_cap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx),
            "::",
            stringify!(entries_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enc_idx>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_enc_idx>())).entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx),
            "::",
            stringify!(entry)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_encoder_cmd {
    pub cmd: __u32,
    pub flags: __u32,
    pub __bindgen_anon_1: v4l2_encoder_cmd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_encoder_cmd__bindgen_ty_1 {
    pub raw: v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub data: [__u32; 8usize],
}
#[test]
fn bindgen_test_layout_v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_encoder_cmd__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_encoder_cmd__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_encoder_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_encoder_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_encoder_cmd__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_encoder_cmd__bindgen_ty_1>())).raw as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_encoder_cmd__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_encoder_cmd() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_encoder_cmd>(),
        40usize,
        concat!("Size of: ", stringify!(v4l2_encoder_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_encoder_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_encoder_cmd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_encoder_cmd>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_encoder_cmd),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_encoder_cmd>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_encoder_cmd),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_decoder_cmd {
    pub cmd: __u32,
    pub flags: __u32,
    pub __bindgen_anon_1: v4l2_decoder_cmd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_decoder_cmd__bindgen_ty_1 {
    pub stop: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1,
    pub start: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2,
    pub raw: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub pts: __u64,
}
#[test]
fn bindgen_test_layout_v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1>())).pts as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2 {
    pub speed: __s32,
    pub format: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2>())).speed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2>())).format
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3 {
    pub data: [__u32; 16usize],
}
#[test]
fn bindgen_test_layout_v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_decoder_cmd__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_decoder_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_decoder_cmd__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_decoder_cmd__bindgen_ty_1>())).stop as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_decoder_cmd__bindgen_ty_1>())).start as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_decoder_cmd__bindgen_ty_1>())).raw as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_decoder_cmd() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_decoder_cmd>(),
        72usize,
        concat!("Size of: ", stringify!(v4l2_decoder_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_decoder_cmd>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_decoder_cmd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_decoder_cmd>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_decoder_cmd>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_vbi_format {
    pub sampling_rate: __u32,
    pub offset: __u32,
    pub samples_per_line: __u32,
    pub sample_format: __u32,
    pub start: [__s32; 2usize],
    pub count: [__u32; 2usize],
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_vbi_format() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_vbi_format>(),
        44usize,
        concat!("Size of: ", stringify!(v4l2_vbi_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_vbi_format>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_vbi_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_vbi_format>())).sampling_rate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(sampling_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_vbi_format>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_vbi_format>())).samples_per_line as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(samples_per_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_vbi_format>())).sample_format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(sample_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_vbi_format>())).start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_vbi_format>())).count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_vbi_format>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_vbi_format>())).reserved as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_sliced_vbi_format {
    pub service_set: __u16,
    pub service_lines: [[__u16; 24usize]; 2usize],
    pub io_size: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_sliced_vbi_format() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_sliced_vbi_format>(),
        112usize,
        concat!("Size of: ", stringify!(v4l2_sliced_vbi_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_sliced_vbi_format>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_sliced_vbi_format))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_sliced_vbi_format>())).service_set as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_format),
            "::",
            stringify!(service_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_sliced_vbi_format>())).service_lines as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_format),
            "::",
            stringify!(service_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sliced_vbi_format>())).io_size as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_format),
            "::",
            stringify!(io_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sliced_vbi_format>())).reserved as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_format),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_sliced_vbi_cap {
    pub service_set: __u16,
    pub service_lines: [[__u16; 24usize]; 2usize],
    pub type_: __u32,
    pub reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_sliced_vbi_cap() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_sliced_vbi_cap>(),
        116usize,
        concat!("Size of: ", stringify!(v4l2_sliced_vbi_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_sliced_vbi_cap>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_sliced_vbi_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sliced_vbi_cap>())).service_set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_cap),
            "::",
            stringify!(service_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_sliced_vbi_cap>())).service_lines as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_cap),
            "::",
            stringify!(service_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sliced_vbi_cap>())).type_ as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_cap),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sliced_vbi_cap>())).reserved as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_cap),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_sliced_vbi_data {
    pub id: __u32,
    pub field: __u32,
    pub line: __u32,
    pub reserved: __u32,
    pub data: [__u8; 48usize],
}
#[test]
fn bindgen_test_layout_v4l2_sliced_vbi_data() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_sliced_vbi_data>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_sliced_vbi_data))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_sliced_vbi_data>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_sliced_vbi_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sliced_vbi_data>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_data),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sliced_vbi_data>())).field as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_data),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sliced_vbi_data>())).line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_data),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sliced_vbi_data>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_data),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sliced_vbi_data>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_data),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_mpeg_vbi_itv0_line {
    pub id: __u8,
    pub data: [__u8; 42usize],
}
#[test]
fn bindgen_test_layout_v4l2_mpeg_vbi_itv0_line() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_mpeg_vbi_itv0_line>(),
        43usize,
        concat!("Size of: ", stringify!(v4l2_mpeg_vbi_itv0_line))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_mpeg_vbi_itv0_line>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_mpeg_vbi_itv0_line))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_mpeg_vbi_itv0_line>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_itv0_line),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_mpeg_vbi_itv0_line>())).data as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_itv0_line),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_mpeg_vbi_itv0 {
    pub linemask: [__le32; 2usize],
    pub line: [v4l2_mpeg_vbi_itv0_line; 35usize],
}
#[test]
fn bindgen_test_layout_v4l2_mpeg_vbi_itv0() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_mpeg_vbi_itv0>(),
        1513usize,
        concat!("Size of: ", stringify!(v4l2_mpeg_vbi_itv0))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_mpeg_vbi_itv0>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_mpeg_vbi_itv0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_mpeg_vbi_itv0>())).linemask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_itv0),
            "::",
            stringify!(linemask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_mpeg_vbi_itv0>())).line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_itv0),
            "::",
            stringify!(line)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_mpeg_vbi_ITV0 {
    pub line: [v4l2_mpeg_vbi_itv0_line; 36usize],
}
#[test]
fn bindgen_test_layout_v4l2_mpeg_vbi_ITV0() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_mpeg_vbi_ITV0>(),
        1548usize,
        concat!("Size of: ", stringify!(v4l2_mpeg_vbi_ITV0))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_mpeg_vbi_ITV0>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_mpeg_vbi_ITV0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_mpeg_vbi_ITV0>())).line as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_ITV0),
            "::",
            stringify!(line)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_mpeg_vbi_fmt_ivtv {
    pub magic: [__u8; 4usize],
    pub __bindgen_anon_1: v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1 {
    pub itv0: v4l2_mpeg_vbi_itv0,
    pub ITV0: v4l2_mpeg_vbi_ITV0,
}
#[test]
fn bindgen_test_layout_v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1>(),
        1548usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1>())).itv0 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1),
            "::",
            stringify!(itv0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1>())).ITV0 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1),
            "::",
            stringify!(ITV0)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_mpeg_vbi_fmt_ivtv() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_mpeg_vbi_fmt_ivtv>(),
        1552usize,
        concat!("Size of: ", stringify!(v4l2_mpeg_vbi_fmt_ivtv))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_mpeg_vbi_fmt_ivtv>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_mpeg_vbi_fmt_ivtv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_mpeg_vbi_fmt_ivtv>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_fmt_ivtv),
            "::",
            stringify!(magic)
        )
    );
}
#[doc = " struct v4l2_plane_pix_format - additional, per-plane format definition"]
#[doc = " @sizeimage:\t\tmaximum size in bytes required for data, for which"]
#[doc = "\t\t\tthis plane will be used"]
#[doc = " @bytesperline:\tdistance in bytes between the leftmost pixels in two"]
#[doc = "\t\t\tadjacent lines"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_plane_pix_format {
    pub sizeimage: __u32,
    pub bytesperline: __u32,
    pub reserved: [__u16; 6usize],
}
#[test]
fn bindgen_test_layout_v4l2_plane_pix_format() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_plane_pix_format>(),
        20usize,
        concat!("Size of: ", stringify!(v4l2_plane_pix_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_plane_pix_format>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_plane_pix_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_plane_pix_format>())).sizeimage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane_pix_format),
            "::",
            stringify!(sizeimage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_plane_pix_format>())).bytesperline as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane_pix_format),
            "::",
            stringify!(bytesperline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_plane_pix_format>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane_pix_format),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct v4l2_pix_format_mplane - multiplanar format definition"]
#[doc = " @width:\t\timage width in pixels"]
#[doc = " @height:\t\timage height in pixels"]
#[doc = " @pixelformat:\tlittle endian four character code (fourcc)"]
#[doc = " @field:\t\tenum v4l2_field; field order (for interlaced video)"]
#[doc = " @colorspace:\t\tenum v4l2_colorspace; supplemental to pixelformat"]
#[doc = " @plane_fmt:\t\tper-plane information"]
#[doc = " @num_planes:\t\tnumber of planes for this format"]
#[doc = " @flags:\t\tformat flags (V4L2_PIX_FMT_FLAG_*)"]
#[doc = " @ycbcr_enc:\t\tenum v4l2_ycbcr_encoding, Y'CbCr encoding"]
#[doc = " @quantization:\tenum v4l2_quantization, colorspace quantization"]
#[doc = " @xfer_func:\t\tenum v4l2_xfer_func, colorspace transfer function"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_pix_format_mplane {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub colorspace: __u32,
    pub plane_fmt: [v4l2_plane_pix_format; 8usize],
    pub num_planes: __u8,
    pub flags: __u8,
    pub __bindgen_anon_1: v4l2_pix_format_mplane__bindgen_ty_1,
    pub quantization: __u8,
    pub xfer_func: __u8,
    pub reserved: [__u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_pix_format_mplane__bindgen_ty_1 {
    pub ycbcr_enc: __u8,
    pub hsv_enc: __u8,
}
#[test]
fn bindgen_test_layout_v4l2_pix_format_mplane__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_pix_format_mplane__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_pix_format_mplane__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_pix_format_mplane__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_pix_format_mplane__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_pix_format_mplane__bindgen_ty_1>())).ycbcr_enc as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane__bindgen_ty_1),
            "::",
            stringify!(ycbcr_enc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_pix_format_mplane__bindgen_ty_1>())).hsv_enc as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane__bindgen_ty_1),
            "::",
            stringify!(hsv_enc)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_pix_format_mplane() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_pix_format_mplane>(),
        192usize,
        concat!("Size of: ", stringify!(v4l2_pix_format_mplane))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_pix_format_mplane>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_pix_format_mplane))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format_mplane>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format_mplane>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_pix_format_mplane>())).pixelformat as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(pixelformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format_mplane>())).field as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_pix_format_mplane>())).colorspace as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_pix_format_mplane>())).plane_fmt as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(plane_fmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_pix_format_mplane>())).num_planes as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(num_planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format_mplane>())).flags as *const _ as usize },
        181usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_pix_format_mplane>())).quantization as *const _ as usize
        },
        183usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(quantization)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_pix_format_mplane>())).xfer_func as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(xfer_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_pix_format_mplane>())).reserved as *const _ as usize },
        185usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct v4l2_sdr_format - SDR format definition"]
#[doc = " @pixelformat:\tlittle endian four character code (fourcc)"]
#[doc = " @buffersize:\t\tmaximum size in bytes required for data"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_sdr_format {
    pub pixelformat: __u32,
    pub buffersize: __u32,
    pub reserved: [__u8; 24usize],
}
#[test]
fn bindgen_test_layout_v4l2_sdr_format() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_sdr_format>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_sdr_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_sdr_format>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_sdr_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sdr_format>())).pixelformat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sdr_format),
            "::",
            stringify!(pixelformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sdr_format>())).buffersize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sdr_format),
            "::",
            stringify!(buffersize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_sdr_format>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sdr_format),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct v4l2_meta_format - metadata format definition"]
#[doc = " @dataformat:\t\tlittle endian four character code (fourcc)"]
#[doc = " @buffersize:\t\tmaximum size in bytes required for data"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_meta_format {
    pub dataformat: __u32,
    pub buffersize: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_meta_format() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_meta_format>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_meta_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_meta_format>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_meta_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_meta_format>())).dataformat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_meta_format),
            "::",
            stringify!(dataformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_meta_format>())).buffersize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_meta_format),
            "::",
            stringify!(buffersize)
        )
    );
}
#[doc = " struct v4l2_format - stream data format"]
#[doc = " @type:\tenum v4l2_buf_type; type of the data stream"]
#[doc = " @pix:\tdefinition of an image format"]
#[doc = " @pix_mp:\tdefinition of a multiplanar image format"]
#[doc = " @win:\tdefinition of an overlaid image"]
#[doc = " @vbi:\traw VBI capture or output parameters"]
#[doc = " @sliced:\tsliced VBI capture or output parameters"]
#[doc = " @raw_data:\tplaceholder for future extensions and custom formats"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_format {
    pub type_: __u32,
    pub fmt: v4l2_format__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_format__bindgen_ty_1 {
    pub pix: v4l2_pix_format,
    pub pix_mp: v4l2_pix_format_mplane,
    pub win: v4l2_window,
    pub vbi: v4l2_vbi_format,
    pub sliced: v4l2_sliced_vbi_format,
    pub sdr: v4l2_sdr_format,
    pub meta: v4l2_meta_format,
    pub raw_data: [__u8; 200usize],
}
#[test]
fn bindgen_test_layout_v4l2_format__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_format__bindgen_ty_1>(),
        200usize,
        concat!("Size of: ", stringify!(v4l2_format__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_format__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_format__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_format__bindgen_ty_1>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_format__bindgen_ty_1>())).pix_mp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(pix_mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_format__bindgen_ty_1>())).win as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(win)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_format__bindgen_ty_1>())).vbi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(vbi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_format__bindgen_ty_1>())).sliced as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(sliced)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_format__bindgen_ty_1>())).sdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(sdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_format__bindgen_ty_1>())).meta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_format__bindgen_ty_1>())).raw_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(raw_data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_format() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_format>(),
        208usize,
        concat!("Size of: ", stringify!(v4l2_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_format>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_format>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_format>())).fmt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format),
            "::",
            stringify!(fmt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_streamparm {
    pub type_: __u32,
    pub parm: v4l2_streamparm__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_streamparm__bindgen_ty_1 {
    pub capture: v4l2_captureparm,
    pub output: v4l2_outputparm,
    pub raw_data: [__u8; 200usize],
}
#[test]
fn bindgen_test_layout_v4l2_streamparm__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_streamparm__bindgen_ty_1>(),
        200usize,
        concat!("Size of: ", stringify!(v4l2_streamparm__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_streamparm__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_streamparm__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_streamparm__bindgen_ty_1>())).capture as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_streamparm__bindgen_ty_1),
            "::",
            stringify!(capture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_streamparm__bindgen_ty_1>())).output as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_streamparm__bindgen_ty_1),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_streamparm__bindgen_ty_1>())).raw_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_streamparm__bindgen_ty_1),
            "::",
            stringify!(raw_data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_streamparm() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_streamparm>(),
        204usize,
        concat!("Size of: ", stringify!(v4l2_streamparm))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_streamparm>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_streamparm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_streamparm>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_streamparm),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_streamparm>())).parm as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_streamparm),
            "::",
            stringify!(parm)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_event_vsync {
    pub field: __u8,
}
#[test]
fn bindgen_test_layout_v4l2_event_vsync() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_vsync>(),
        1usize,
        concat!("Size of: ", stringify!(v4l2_event_vsync))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_vsync>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_event_vsync))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_vsync>())).field as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_vsync),
            "::",
            stringify!(field)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_event_ctrl {
    pub changes: __u32,
    pub type_: __u32,
    pub __bindgen_anon_1: v4l2_event_ctrl__bindgen_ty_1,
    pub flags: __u32,
    pub minimum: __s32,
    pub maximum: __s32,
    pub step: __s32,
    pub default_value: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_event_ctrl__bindgen_ty_1 {
    pub value: __s32,
    pub value64: __s64,
}
#[test]
fn bindgen_test_layout_v4l2_event_ctrl__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_ctrl__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_event_ctrl__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_ctrl__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_event_ctrl__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_event_ctrl__bindgen_ty_1>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_event_ctrl__bindgen_ty_1>())).value64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl__bindgen_ty_1),
            "::",
            stringify!(value64)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_event_ctrl() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_ctrl>(),
        40usize,
        concat!("Size of: ", stringify!(v4l2_event_ctrl))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_ctrl>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_event_ctrl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_ctrl>())).changes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(changes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_ctrl>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_ctrl>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_ctrl>())).minimum as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_ctrl>())).maximum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_ctrl>())).step as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_ctrl>())).default_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(default_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_event_frame_sync {
    pub frame_sequence: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_event_frame_sync() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_frame_sync>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_event_frame_sync))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_frame_sync>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_event_frame_sync))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_event_frame_sync>())).frame_sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_frame_sync),
            "::",
            stringify!(frame_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_event_src_change {
    pub changes: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_event_src_change() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_src_change>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_event_src_change))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_src_change>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_event_src_change))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_src_change>())).changes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_src_change),
            "::",
            stringify!(changes)
        )
    );
}
#[doc = " struct v4l2_event_motion_det - motion detection event"]
#[doc = " @flags:             if V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ is set, then the"]
#[doc = "                     frame_sequence field is valid."]
#[doc = " @frame_sequence:    the frame sequence number associated with this event."]
#[doc = " @region_mask:       which regions detected motion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_event_motion_det {
    pub flags: __u32,
    pub frame_sequence: __u32,
    pub region_mask: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_event_motion_det() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_motion_det>(),
        12usize,
        concat!("Size of: ", stringify!(v4l2_event_motion_det))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_motion_det>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_event_motion_det))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_motion_det>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_motion_det),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_event_motion_det>())).frame_sequence as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_motion_det),
            "::",
            stringify!(frame_sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_event_motion_det>())).region_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_motion_det),
            "::",
            stringify!(region_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_event {
    pub type_: __u32,
    pub u: v4l2_event__bindgen_ty_1,
    pub pending: __u32,
    pub sequence: __u32,
    pub timestamp: timespec,
    pub id: __u32,
    pub reserved: [__u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_event__bindgen_ty_1 {
    pub vsync: v4l2_event_vsync,
    pub ctrl: v4l2_event_ctrl,
    pub frame_sync: v4l2_event_frame_sync,
    pub src_change: v4l2_event_src_change,
    pub motion_det: v4l2_event_motion_det,
    pub data: [__u8; 64usize],
}
#[test]
fn bindgen_test_layout_v4l2_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_event__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event__bindgen_ty_1>())).vsync as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(vsync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event__bindgen_ty_1>())).ctrl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_event__bindgen_ty_1>())).frame_sync as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(frame_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_event__bindgen_ty_1>())).src_change as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(src_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_event__bindgen_ty_1>())).motion_det as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(motion_det)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event__bindgen_ty_1>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_event() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_event>(),
        136usize,
        concat!("Size of: ", stringify!(v4l2_event))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event>())).pending as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event>())).sequence as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event>())).timestamp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event>())).id as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event>())).reserved as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_event_subscription {
    pub type_: __u32,
    pub id: __u32,
    pub flags: __u32,
    pub reserved: [__u32; 5usize],
}
#[test]
fn bindgen_test_layout_v4l2_event_subscription() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_subscription>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_event_subscription))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_subscription>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_event_subscription))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_subscription>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_subscription),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_subscription>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_subscription),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_event_subscription>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_subscription),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_event_subscription>())).reserved as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_subscription),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_match {
    pub type_: __u32,
    pub __bindgen_anon_1: v4l2_dbg_match__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dbg_match__bindgen_ty_1 {
    pub addr: __u32,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_v4l2_dbg_match__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_dbg_match__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_dbg_match__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dbg_match__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_dbg_match__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_dbg_match__bindgen_ty_1>())).addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_match__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_dbg_match__bindgen_ty_1>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_match__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_dbg_match() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_dbg_match>(),
        36usize,
        concat!("Size of: ", stringify!(v4l2_dbg_match))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dbg_match>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_dbg_match))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dbg_match>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_match),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_register {
    pub match_: v4l2_dbg_match,
    pub size: __u32,
    pub reg: __u64,
    pub val: __u64,
}
#[test]
fn bindgen_test_layout_v4l2_dbg_register() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_dbg_register>(),
        56usize,
        concat!("Size of: ", stringify!(v4l2_dbg_register))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dbg_register>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_dbg_register))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dbg_register>())).match_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_register),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dbg_register>())).size as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_register),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dbg_register>())).reg as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_register),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dbg_register>())).val as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_register),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_chip_info {
    pub match_: v4l2_dbg_match,
    pub name: [::std::os::raw::c_char; 32usize],
    pub flags: __u32,
    pub reserved: [__u32; 32usize],
}
#[test]
fn bindgen_test_layout_v4l2_dbg_chip_info() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_dbg_chip_info>(),
        200usize,
        concat!("Size of: ", stringify!(v4l2_dbg_chip_info))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dbg_chip_info>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_dbg_chip_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dbg_chip_info>())).match_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_chip_info),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dbg_chip_info>())).name as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_chip_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dbg_chip_info>())).flags as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_chip_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_dbg_chip_info>())).reserved as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_chip_info),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct v4l2_create_buffers - VIDIOC_CREATE_BUFS argument"]
#[doc = " @index:\ton return, index of the first created buffer"]
#[doc = " @count:\tentry: number of requested buffers,"]
#[doc = "\t\treturn: number of created buffers"]
#[doc = " @memory:\tenum v4l2_memory; buffer memory type"]
#[doc = " @format:\tframe format, for which buffers are requested"]
#[doc = " @capabilities: capabilities of this buffer type."]
#[doc = " @reserved:\tfuture extensions"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_create_buffers {
    pub index: __u32,
    pub count: __u32,
    pub memory: __u32,
    pub format: v4l2_format,
    pub capabilities: __u32,
    pub reserved: [__u32; 7usize],
}
#[test]
fn bindgen_test_layout_v4l2_create_buffers() {
    assert_eq!(
        ::std::mem::size_of::<v4l2_create_buffers>(),
        256usize,
        concat!("Size of: ", stringify!(v4l2_create_buffers))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_create_buffers>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_create_buffers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_create_buffers>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_create_buffers>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_create_buffers>())).memory as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_create_buffers>())).format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<v4l2_create_buffers>())).capabilities as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<v4l2_create_buffers>())).reserved as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(reserved)
        )
    );
}
